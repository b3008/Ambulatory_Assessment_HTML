{"version":3,"sources":["webpack://executableHTML/webpack/universalModuleDefinition","webpack://executableHTML/webpack/bootstrap","webpack://executableHTML/(webpack)/buildin/amd-options.js","webpack://executableHTML/(webpack)/buildin/global.js","webpack://executableHTML/(webpack)/buildin/harmony-module.js","webpack://executableHTML/./src/customElements/aa-affect-grid/aa-affect-grid.js","webpack://executableHTML/./src/customElements/aa-baseElement/baseElement.js","webpack://executableHTML/./src/customElements/aa-checkboxes/aa-checkboxes.js","webpack://executableHTML/./src/customElements/aa-choice-item/aa-choice-item.js","webpack://executableHTML/./src/customElements/aa-choose/aa-choose.js","webpack://executableHTML/./src/customElements/aa-choose/aa-otherwise/aa-otherwise.js","webpack://executableHTML/./src/customElements/aa-choose/aa-when/aa-when.js","webpack://executableHTML/./src/customElements/aa-function/aa-function-random.js","webpack://executableHTML/./src/customElements/aa-label/aa-label.js","webpack://executableHTML/./src/customElements/aa-likert-scale/aa-likert-scale.js","webpack://executableHTML/./src/customElements/aa-memory/aa-memory.js","webpack://executableHTML/./src/customElements/aa-multiple-choice/aa-multiple-choice.js","webpack://executableHTML/./src/customElements/aa-screen/aa-screen.js","webpack://executableHTML/./src/customElements/aa-sequence/aa-jump/aa-jump.js","webpack://executableHTML/./src/customElements/aa-sequence/aa-sequence.js","webpack://executableHTML/./src/customElements/aa-session/aa-session.js","webpack://executableHTML/./src/customElements/aa-slider/aa-slider.js","webpack://executableHTML/./src/customElements/aa-text-answer/aa-text-answer.js","webpack://executableHTML/./src/customElements/aa-variable/aa-variable.js","webpack://executableHTML/./src/index.js","webpack://executableHTML/./src/lib/html2jsl/html2jsl.js","webpack://executableHTML/./src/lib/jsep/jsep.js","webpack://executableHTML/./src/lib/yaml/js-yaml.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;;;;;;;;;;;;;ACDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAA2D;AAC5C,2BAA2B,sEAAW;;;;AAIrD;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;;;;AAItD;;;;AAIA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,SAAS;AACT;AACA;;;;;;AAMA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,aAAa,IAAI,iBAAiB;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,oBAAoB,aAAa;AACjC,wBAAwB,gBAAgB;AACxC,+CAA+C,cAAc,GAAG,2BAA2B,IAAI,eAAe,IAAI,6BAA6B,YAAY,gCAAgC,YAAY,4BAA4B;AACnO;AACA;AACA;;AAEA;AACA,kEAAkE,cAAc,uBAAuB;;AAEvG,6DAA6D;AAC7D;AACA,2CAA2C,cAAc,oBAAoB;AAC7E,0EAA0E,kBAAkB;AAC5F,kEAAkE,sBAAsB,cAAc;AACtG,2EAA2E,mBAAmB;AAC9F;AACA;AACA;;;AAGA,gEAAgE;AAChE,iEAAiE,uBAAuB;AACxF,4DAA4D,KAAK;AACjE,kEAAkE;AAClE;;;AAGA,gEAAgE,oBAAoB;AACpF;AACA,uCAAuC,cAAc,oBAAoB;AACzE,yEAAyE,qBAAqB;AAC9F,oEAAoE,iBAAiB;AACrF,0EAA0E,sBAAsB;;AAEhG;AACA;;AAEA;;AAEA,iEAAiE,aAAa,UAAU,eAAe,oBAAoB,+BAA+B,0BAA0B,2BAA2B;AAC/M,4CAA4C,iBAAiB,KAAK,qBAAqB;AACvF,4CAA4C,mBAAmB,gBAAgB,eAAe;AAC9F,4CAA4C,oBAAoB,kBAAkB;AAClF;;AAEA,kEAAkE,aAAa,YAAY,cAAc,oBAAoB,+BAA+B,yBAAyB,+BAA+B;AACpN,4CAA4C,oBAAoB,mBAAmB;AACnF,4CAA4C,mBAAmB,gBAAgB,gBAAgB;AAC/F,4CAA4C,qBAAqB,sBAAsB;AACvF;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA,sEAAW,mD;;;;;;;;;;;;AChbX;AAAA;AAAA;AAAA;AAAmC;AACnC;AAC2D;;AAE3D;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA,SAAS;AACT,2BAA2B,4BAA4B;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,0CAA0C;AACrE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;;;AAGb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;;AAGA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,gDAAgD,aAAa;AAC7D,sDAAsD,cAAc;AACpE,8BAA8B,eAAe;AAC7C,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;;AAEA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;AAEA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,eAAe,mEAAkB;AACjC;;;;;;AAMA;AACA;AACA,8DAA8D,wBAAwB;AACtF;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;ACzVA;AAAA;AAAA;AAAA;AAA2D;AACd;;AAE9B,2BAA2B,sEAAW;;;;AAIrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;;;;AAKb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;;AAGA,aAAa,sEAAW;AACxB,kCAAkC,sEAAW;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;;AAEA;AACA,sB;AACA;;AAEA;;;AAGA,sEAAW,kD;;;;;;;;;;;;AC3JX;AAAA;AAAA;AAA2D;AAC5C,2BAA2B,sEAAW;;;AAGrD;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sEAAW,mD;;;;;;;;;;;;ACxCX;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6D;AAC/B;AACU;;;AAGE;AAC3B,uBAAuB,sEAAW;;;AAGjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,gBAAgB,sEAAW;AAC3B;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,kBAAkB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,0BAA0B;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;AACA;AACA;AACA,uCAAuC,sEAAW;AAClD;AACA,aAAa;AACb,mCAAmC,sEAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4BAA4B,iEAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB,EAAE,mBAAmB,EAAE,sBAAsB;AAClG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,4CAA4C,qBAAqB;AACjE,6CAA6C,sBAAsB;AACnE,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;;AC1LX;AAAA;AAAA;AAA8D;;AAE/C,0BAA0B,sEAAW;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,sEAAW;;;;;;;;;;;;;AClBX;AAAA;AAAA;AAAgE;;AAEjD,qBAAqB,sEAAW;;;AAG/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;;AC9CX;AAAA;AAAA;AAA2D;;AAE5C,+BAA+B,sEAAW;;;AAGzD;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;;AAGb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD,0BAA0B,eAAe;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,sEAAW;;;;;;;;;;;;;;AC5EX;AAAA;AAAA;AAA2D;AAC5C,sBAAsB,sEAAW;;AAEhD;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAW,wC;;;;;;;;;;;;AClCX;AAAA;AAAA;AAAA;AAA2D;AACN;;AAEtC,4BAA4B,sEAAW;;;AAGtD;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;;AAEA,uCAAuC,eAAe;;;AAGtD;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA,6CAA6C,uBAAuB,uCAAuC;AAC3G,8CAA8C,uBAAuB,wCAAwC;AAC7G,2CAA2C,uBAAuB,qCAAqC;AACvG;;;;AAIA;AACA,oBAAoB,UAAU;;;;AAI9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA,S;;AAEA,wEAAwE,YAAY,cAAc,8BAA8B,sBAAsB,EAAE;AACxJ;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,cAAc;AAClC,8CAA8C,YAAY,IAAI,YAAY;AAC1E;AACA;AACA,8EAA8E,UAAU,IAAI,MAAM;AAClG,kCAAkC,e;AAClC;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA,iC;AACA;;;;;AAKA;;AAEA,sEAAW;;;;;;;;;;;;;;AClKX;AAAA;AAAA;AAA4D;;;;AAI7C,uBAAuB,sEAAW;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;AC3BX;AAAA;AAAA;AAAA;AAA2D;AACd;;AAE9B,+BAA+B,sEAAW;;;;AAIzD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,sEAAW;AACxB,kCAAkC,sEAAW;AAC7C,SAAS;AACT;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;;AAEA;AACA,sB;AACA;AACA;;;AAGA,sEAAW,2D;;;;;;;;;;;;ACnLX;AAAA;AAAA;AAA6D;;;AAG9C,uBAAuB,sEAAW;;;;AAIjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4FAA4F,WAAW;AACvG,SAAS;AACT,uDAAuD,WAAW;AAClE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA,kEAAkE,iBAAiB,qBAAqB,oBAAoB;AAC5H,iEAAiE,c;AACjE;AACA,6DAA6D;AAC7D;AACA;;AAEA,+DAA+D,yBAAyB,yBAAyB,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AAOA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,0BAA0B;AACjD,gBAAgB,sEAAW,iCAAiC,+BAA+B;AAC3F;AACA;AACA;;;;AAIA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA,aAAa;AACb,6BAA6B,oBAAoB;AACjD,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,uBAAuB,0BAA0B;AACjD,gBAAgB,sEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;;ACpQX;AAAA;AAAA;AAA8D;;AAE/C,qBAAqB,sEAAW;;;;AAI/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;ACjCX;AAAA;AAAA;AAAA;AAA6D;AAC/B;;;;AAIf,yBAAyB,sEAAW;;AAEnD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;;AAEA;;;AAGA,+BAA+B,QAAQ;AACvC;;AAEA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,sEAAW;AACnD;AACA;AACA;AACA,0EAA0E,QAAQ;AAClF;AACA;AACA,oCAAoC,sEAAW;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,6CAA6C,iBAAiB;AAC9D,kBAAkB,mCAAmC;AACrD,SAAS;AACT;AACA;AACA;;;;;;;;AAQA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,wBAAwB;;AAE5C,uCAAuC,EAAE,iBAAiB,MAAM,YAAY,OAAO;AACnF,wBAAwB,EAAE,QAAQ,SAAS,QAAQ,KAAK,QAAQ,SAAS;;AAEzE;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;;;;;;;AAOA;;AAEA,sEAAW;;;;;;;;;;;;;;;ACvNX;AAAA;AAAA;AAAA;AAAA;AAA4D;;AAExB;AACwB;;AAE7C,wBAAwB,sEAAW;;AAElD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;AACA;AACA;;AAEA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,mEAAmE,yBAAyB,QAAQ,EAAE;AACtG;AACA;AACA;AACA;AACA;;;AAGA,SAAS;;AAET;AACA;AACA,sEAAsE,sCAAsC;AAC5G;AACA,SAAS;;;AAGT;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA,QAAQ,sEAAW;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,qEAAqE;AAC5F;AACA,qBAAqB,sEAAW;AAChC;AACA;AACA;AACA;AACA,4CAA4C,cAAc,yBAAyB,EAAE;AACrF;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C,2BAA2B,mEAAkB;AAC7C;AACA,iCAAiC,mEAAkB;;AAEnD;AACA;;AAEA;;AAEA;AACA,6BAA6B,yEAAwB,eAAe;AACpE,oBAAoB,yEAAwB;;AAE5C;AACA;;;;;AAKA;;AAEA;AACA,uBAAuB,uBAAuB;;AAE9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,sEAAW;;;;;;;;;;;;;;;;;;;;AC9MX;AAAA;AAAA;AAA2D;AAC5C,uBAAuB,sEAAW;;;;AAIjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,uCAAuC,eAAe;;AAEtD,kEAAkE,UAAU;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;AACvB,oBAAoB,8BAA8B;;AAElD;AACA;AACA,SAAS;AACT;;;;AAIA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,4B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uEAAuE,SAAS,OAAO,SAAS;AAChG,+EAA+E,SAAS,SAAS,SAAS,WAAW,sBAAsB;;;AAG3I;AACA,eAAe,aAAa;AAC5B,iCAAiC;AACjC,oCAAoC,oBAAoB;AACxD,6DAA6D,oBAAoB;AACjF;AACA;AACA;AACA;;;AAGA;;AAEA,sEAAW,0C;;;;;;;;;;;;AC/JX;AAAA;AAAA;AAA2D;AAC5C,2BAA2B,sEAAW;;;;AAIrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA,wEAAwE,KAAK;;AAE7E;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,oBAAoB,8BAA8B;AAClD;;AAEA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,iBAAiB;AACjB;AACA,SAAS;;AAET;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,4B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,UAAU;AAC9C,8BAA8B,UAAU;AACxC,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;;AAEA,sEAAW,mD;;;;;;;;;;;;AC9LX;AAAA;AAAA;AAA4D;AAC7C,yBAAyB,sEAAW;;AAEnD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD,yBAAyB;AACzB;;;AAGA;;AAEA,sEAAW;;;;;;;;;;;;;;AC1CX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACyE;AACJ;AACa;AACnB;AACI;AACe;AACnB;AACA;AACM;AACH;AACW;AACY;AACZ;AACF;AACK;AACjB;AACc;AACjB;AAC5D;;;;;;;;;;;;;;;;;;;AClBO;;AAEP;AACA;AACA;AACA;AACA,SAAS,OAAO,YAAY,OAAO,GAAG;;AAEtC,KAAK;;;AAGL;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA,6BAA6B,eAAe,OAAO,EAAE;AACrD;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB,eAAe;AACpC,2CAA2C;AAC3C;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,EAAE,8BAA8B;AACxE;AACA;AACA,2BAA2B,MAAM,EAAE,8BAA8B;AACjE;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,UAAU,EAAE,uBAAuB,UAAU,SAAS,sBAAsB,EAAE,KAAK,EAAE;AACrH;AACA;;;;;;;;;;;;;ACnGA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iCAAiC;AACjC,GAAG;AACH;AACA;AACA;AACA;AACA,wEAAwE;AACxE,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iCAAiC,EAAE;AAC5D,6BAA6B,qCAAqC,EAAE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,cAAc;AACd,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,OAAO,gCAAgC;AACvC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,+DAA+D;;AAE5F;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,MAAM,KAA6B;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC,CAAC,SAAI,CAAC,EAAE;;;;;;;;;;;;;;AC/rBT;AAAA;;AAEe,8EAAe,oEAAoE,uBAAuB,0CAA0C,gGAAU,GAAG,gBAAgB,OAAO,OAAO,qCAAqC,aAAa,0CAA0C,aAAa,wCAAwC,WAAW,OAAO,WAAW,iBAAiB,EAAE;AAC/Y,wBAAwB,sBAAsB,mBAAmB,aAAa,aAAa,iDAAiD,qBAAqB,OAAC,QAAQ,wBAAwB,qDAAqD,uCAAuC,iBAAiB,YAAY,GAAG,uCAAuC,oBAAoB,mBAAmB,6BAA6B,sBAAsB,6DAA6D,cAAc,aAAa,WAAW,WAAW;AAC7iB;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK,GAAG,yRAAyR;AACjS;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,IAAI;AACT;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B,gCAAgC;AAChC,sCAAsC;AACtC,4BAA4B;AAC5B,kCAAkC;AAClC,mCAAmC;AACnC,4BAA4B;AAC5B,8BAA8B;AAC9B,gCAAgC;AAChC,mCAAmC;AACnC,+BAA+B;AAC/B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B,mCAAmC;AACnC,+BAA+B;AAC/B,oCAAoC;AACpC,0CAA0C;AAC1C,2CAA2C;AAC3C,mCAAmC;AACnC,yCAAyC,KAAK;AAC9C,oCAAoC;AACpC,0CAA0C,KAAK;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,6CAA6C,gBAAgB;AAC7D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4DAA4D,gBAAgB;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,gBAAgB;;AAEtE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,sDAAsD,gBAAgB;AACtE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,EAAE;AACrC;;AAEA;AACA;;AAEA;;AAEA,iDAAiD,gBAAgB;AACjE;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA,aAAa;AACb;;AAEA,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,0CAA0C,8BAA8B;AACxE;;AAEA;AACA;;AAEA,KAAK,GAAG,2FAA2F;AACnG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA,KAAK,IAAI;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA,4CAA4C,EAAE,eAAe,EAAE,YAAY;;;AAG3E,4BAA4B,4CAA4C;;AAExE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA;;AAEA,qDAAqD,kBAAkB;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,kBAAkB;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA,aAAa;AACb;AACA;;AAEA,oBAAoB,eAAe;AACnC;;AAEA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa;AACb;AACA;;AAEA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA,SAAS,yBAAyB;AAClC,4BAA4B,IAAI;AAChC;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA,kFAAkF;AAClF,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA,cAAc,+CAA+C;AAC7D;;AAEA;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb,mCAAmC;AACnC;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA,aAAa;AACb,kEAAkE,sBAAsB;AACxF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf,yEAAyE;;AAEzE,eAAe;AACf;AACA;AACA,4BAA4B;AAC5B;;AAEA,aAAa;AACb,oEAAoE;;AAEpE,aAAa;AACb;AACA;AACA,0BAA0B;AAC1B;;AAEA,WAAW;AACX,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,cAAc,+CAA+C;AAC7D;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;;AAEA,0EAA0E,0BAA0B;AACpG;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,qFAAqF;AACrF;;AAEA,8CAA8C;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,+CAA+C;AACjE;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sDAAsD,gBAAgB;AACtE;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,8BAA8B;AACrF;;;AAGA;AACA,0CAA0C,8BAA8B;AACxE;;;AAGA;AACA;AACA;AACA;;AAEA,KAAK,GAAG,wGAAwG;AAChH;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,qBAAqB;AACrB;AACA,SAAS;;AAET;AACA;AACA;;AAEA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,iCAAiC,EAAE;AACjF;AACA;;AAEA,0CAA0C,6BAA6B,EAAE;AACzE;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;;AAGA;;AAEA,KAAK,GAAG,gDAAgD;AACxD;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,+BAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,uHAAuH;AAC/H;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,8JAA8J;AACtK;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,0EAA0E;AAClF;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mHAAmH;AAC3H;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,0DAA0D,aAAa;AACvE,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO,aAAa;;AAEpB;;;AAGA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA,qBAAqB,WAAW;AAChC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC,EAAE;AAC5E,wCAAwC,kCAAkC,EAAE;AAC5E,wCAAwC,kCAAkC;AAC1E,SAAS;AACT;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gCAAgC;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6EAA6E,EAAE;AACjH,iCAAiC,2EAA2E,EAAE;AAC9G,mCAAmC,yBAAyB,EAAE;AAC9D;AACA,uCAAuC,2GAA2G;AAClJ,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gCAAgC;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAyC,cAAc;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,cAAc;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;AACA;AACA,oCAAoC,kCAAkC;AACtE,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,EAAE;AAChD,kCAAkC,eAAe,EAAE;AACnD,kCAAkC,eAAe,EAAE;AACnD,kCAAkC,eAAe;AACjD,SAAS;AACT;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+CAA+C,gBAAgB;AAC/D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,+CAA+C,gBAAgB;AAC/D;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,+CAA+C,gBAAgB;AAC/D;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA,oCAAoC,kCAAkC;AACtE,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA,oCAAoC,kCAAkC;AACtE,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;;AAEA,wBAAwB;AACxB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;;AAGA;;;AAGA;;AAEA,KAAK,GAAG,wBAAwB;AAChC,GAAG,IAAI;AACP,CAAC,CAAC,EAAC","file":"aaCustomElements.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"executableHTML\"] = factory();\n\telse\n\t\troot[\"executableHTML\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AAAffectGrid extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n\n            'top-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'bottom-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'left-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'center-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'right-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'top-left-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'top-right-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'bottom-left-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'bottom-right-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'left-top-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'left-bottom-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'right-top-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'right-bottom-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            rows: {\n                type: Number,\n                userDefined: true,\n                value: 11\n            },\n\n            columns: {\n                type: Number,\n                userDefined: true,\n                value: 11\n            },\n\n            value:{\n                type: Array,\n\n            }\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAAffectGrid.properties);\n    }\n\n\n\n\n    get value() {\n        if (!this.inputItem) {\n            return this.getAttribute('value');\n        }\n        return this.inputItem.value;\n    }\n    set value(val) {\n        this.setAttribute('value', val);\n        if (this.inputItem) {\n            this.inputItem.value = val;\n        }\n\n    }\n\n    get minLabel() {\n        return this.getAttribute('min-label');\n    }\n\n    get maxLabel() {\n        return this.getAttribute('max-label');\n    }\n\n    set minLabel(val) {\n        this.setAttribute('min-label', val);\n        if (this.inputItem) {\n            this.inputItem.minLabel = val;\n        }\n    }\n\n    set maxLabel(val) {\n        this.setAttribute('max-label', val);\n        if (this.inputItem) {\n            this.inputItem.maxLabel = val;\n        }\n    }\n\n    set min(val) {\n        this.setAttribute('min', val);\n        if (this.inputItem) {\n            this.inputItem.min = val;\n        }\n    }\n\n    set max(val) {\n        this.setAttribute('max', val);\n        if (this.inputItem) {\n            this.inputItem.max = val;\n        }\n    }\n\n\n    constructor() {\n        super();\n\n        if(this.topLeftLabel === null) this.topLeftLabel='';\n        if(this.topLabel === null) this.topLabel='';\n        if(this.topRightLabel === null) this.topLRightLabel='';\n        if(this.leftTopLabel === null) this.leftTopLabel='';\n        if(this.leftLabel === null) this.leftLabel='';\n        if(this.leftBottomLabel === null) this.leftBottomLabel='';\n        if(this.rightTopLabel === null) this.rightTopLabel='';\n        if(this.rightLabel === null) this.rightLabel='';\n        if(this.rightBottomLabel === null) this.rightBottomLabel='';\n        if(this.bottomLeftLabel === null) this.bottomLeftLabel='';\n        if(this.bottomLabel === null) this.bottomLabel='';\n        if(this.bottomRightLabel === null) this.bottomRightLabel='';\n        this.root = this.attachShadow({ mode: 'open' });\n\n        \n        \n    }\n\n\n\n    connectedCallback() {\n        super.connectedCallback();\n\n\n        this.root.innerHTML = this.css + this.html;\n\n        // this.topLeft = this.root.querySelector('.top-left');\n       \n        // this.topRight = this.root.querySelector('.top-right');\n        // this.leftMargin =  this.root.querySelector('.left-margin');\n        // this.rightMargin = this.root.querySelector('.right-margin');\n        \n\n        \n\n        this.grid = this.root.querySelector('.grid');\n        this.grid.addEventListener(\"click\", (e)=>{\n            let cell = e.path[0];\n            this.value = [cell.dataset.x, cell.dataset.y];\n            \n            \n            if(this.selectedCell){\n                this.selectedCell.classList.remove('selected');\n            }\n            this.selectedCell = cell;\n            this.selectedCell.classList.add('selected');\n\n\n            // console.log(this.value);\n            // console.log(typeof this.value);\n        });\n\n        this.totalContainer = this.root.querySelector('.total-container');\n\n        this.totalContainer.style.height = window.getComputedStyle(this.totalContainer).width;\n        this.root.querySelector(\".leftLabels\").style.width = window.getComputedStyle(this.grid).height;\n        this.root.querySelector(\".rightLabels\").style.width = window.getComputedStyle(this.grid).height;\n        \n        //register a resize observer for top container\n        if(ResizeObserver){\n            new ResizeObserver( ()=>{\n                console.log(\"resize\");\n                this.totalContainer.style.height = window.getComputedStyle(this.totalContainer).width;\n                this.root.querySelector(\".leftLabels\").style.width = window.getComputedStyle(this.grid).height;\n                this.root.querySelector(\".rightLabels\").style.width = window.getComputedStyle(this.grid).height;\n\n            }).observe(this.root.querySelector('.top-label'));\n        }else{\n            console.warn(\"ResizeObserver is not defined here\");\n        }\n\n       \n\n\n        \n    }\n\n    get css() {\n        return html`<style>\n\n        \n        :host{\n            display:block;\n            font-family: Roboto, Noto, sans-serif;\n            \n        }\n        .top-section{\n            height:40px;\n            width:100%;\n         \n        }\n\n        .top-left{\n            text-align:left;\n        }\n\n        .top-label{\n            text-align:center;\n        }\n        .top-right{\n            text-align:right;\n        }\n\n        .bottom-left{\n            text-align:left;\n        }\n        .bottom{\n            text-align:center;\n        }\n        .bottom-right{\n            text-align:right;\n        }\n\n\n        .top-left-corner{\n            width:40px;\n            height:40px;\n        }\n        .top-right-corner{\n            width:40px;\n            height:40px;\n        }\n\n        .bottom-left-corner{\n            width:40px;\n            height:40px;\n        }\n        .bottom-right-corner{\n            width:40px;\n            height:40px;\n        }\n\n\n        .middle-section{\n         \n            flex-grow:2;\n        }\n\n\n        \n        .bottom-section{\n           \n            height:40px;\n            width:100%;\n        }\n        .left-margin{\n            width:40px;\n            height:100%;\n        }\n        .right-margin{\n            width:40px;\n            height:100%;\n        }\n\n        .grid{\n            display:grid;\n            grid-template-columns: repeat(${this.columns}, ${100/this.columns}%);\n            \n            flex-grow:2;\n            width:100%;\n            height:100%;\n        }\n        .cell{\n            border:solid thin;\n            transition:background-color 0.2s;\n        }\n\n        .cell.top{\n            border-top:solid 2px;\n        }\n\n        .cell.bottom{\n            border-bottom:solid 2px;\n        }\n\n        .cell.left{\n            border-left:solid 2px;\n        }\n\n        .cell.right{\n            border-right: solid 2px;\n        }\n        .cell.selected{\n            background-color: #3367D6;\n            \n        }\n\n\n        .label{\n            flex-grow:1\n        }\n        </style>\n        `;\n    }\n\n    get html() {\n        \n\n        let grid ='';\n        for(let j=0; j<this.rows; j++){\n            for(let i=0; i<this.columns; i++){\n                grid+=html`<div class=\"cell  ${j==0?'top':''} ${j==this.rows-1?`bottom`:''}  ${i==0?`left`:''}  ${i==this.columns-1?`right`:''}\" data-x=\"${Math.round(this.columns/2)-i-1 }\" data-y=\"${j+1-Math.round(this.rows/2)}\">\n            </div>`;\n            }\n        }\n\n        let source = html`\n            <div class=\"total-container\" style=\"position:relative; display:flex; flex-direction:column;\">\n                \n                <div class=\"top-section\" style=\"display:flex; flex-direction:row\">\n                    <div class=\"top-left-corner\"></div>    \n                    <div style=\"width:100%; display:flex; flex-direction:row; justify-content:space-between\">\n                        <div class=\"top-left label\" style=\"width:33.3%\">${this.topLeftLabel}</div>\n                        <div class=\"top-label\" style=\"width:33.3%; text-align:center\">${this.topLabel}</div>\n                        <div class=\"top-right label\" style=\"width:33.3%\">${this.topRightLabel}</div>\n                    </div>\n                    <div class=\"top-right-corner\"></div>    \n                </div>\n            \n                \n                <div class=\"middle-section\" style=\"display:flex; flex-direction:row\">\n                    <div class=\"left-margin\" style=\"display:flex; flex-direction:column;\"></div>\n                    <div class=\"grid\" style=\"padding:0px\">${grid}</div>\n                    <div class=\"right-margin\" style=\"display:flex; flex-direction:column\"></div>\n                </div>\n                \n\n                <div class=\"bottom-section\" style=\"display:flex; flex-direction:row;margin-top:10px\">\n                <div class=\"bottom-left-corner\" ></div>    \n                <div style=\"width:100%; display:flex; flex-direction:row; justify-content:space-between\">\n                    <div class=\"bottom-left label\" style=\"width:33.3%\">${this.bottomLeftLabel}</div>\n                    <div class=\"bottom label\" style=\"width:33.3%\">${this.bottomLabel}</div>\n                    <div class=\"bottom-right label\" style=\"width:33.3%\">${this.bottomRightLabel}</div>\n                \n                </div>\n                    <div class=\"bottom-right-corner\"></div>    \n                \n                </div>\n\n                <div class=\"leftLabels\" style=\"position:absolute; bottom:30px; left:0px;  display:flex; flex-direction:row; justify-content:space-between; transform:rotate(-90deg); transform-origin:top left;\">\n                    <div style=\"width:33.3%; text-align:left; \">${this.leftBottomLabel}</div>    \n                    <div style=\"width:33.3%; text-align:center; flex-grow:2\">${this.leftLabel}</div>    \n                    <div style=\"width:33.3%;text-align:right\">${this.leftTopLabel}</div>    \n                </div>\n\n                <div class=\"rightLabels\" style=\"position:absolute; bottom:50px; right:20px; display:flex; flex-direction:row; justify-content:space-between; transform:rotate(90deg); transform-origin:bottom right;\">\n                    <div style=\"width:33.3%; text-align:left\">${this.rightTopLabel}</div>    \n                    <div style=\"width:33.3%; text-align:center; flex-grow:2\">${this.rightLabel}</div>    \n                    <div style=\"width:33.3%; text-align:right\">${this.rightBottomLabel}</div>    \n                </div>\n\n            </div>\n        \n        `;\n               \n        return source;\n    }\n\n\n}\n\nBaseElement.registerAAElement('aa-affect-grid', AAAffectGrid);","import '../../lib/yaml/js-yaml.js';\n// import * as jsl from '../../lib/jsl/jsl2.1.js';\nimport * as html2jsl from '../../lib/html2jsl/html2jsl.js';\n\nvar html = function (txt, ...val) {\n\n    let result = txt[0];\n    for (let i = 0; i < val.length; i++) {\n        result += val[i];\n        result += txt[i + 1];\n    }\n    return result;\n}\n\nif (window) window.html = html;\n\nexport default class BaseElement extends HTMLElement {\n\n    static registerAAElement(name, elem) {\n        if (!customElements.get(name)) {\n            window.AANodeNames = window.AANodeNames || [];\n            window.AANodeNames.push(name.toUpperCase());\n            customElements.define(name, elem);\n        }\n    }\n\n    static isAAElement(node) {\n        if (AANodeNames.indexOf(node.nodeName) != -1) {\n            return true;\n        }\n        return false;\n    }\n\n    static createFragmentForNode(node) {\n        let fragment = document.createDocumentFragment();\n        for (let i = 0; i < node.childNodes.length; i++) {\n            fragment.append(node.childNodes[i].cloneNode(true));\n            // fragment.append(BaseElement.copy(node.childNodes[i])\n        }\n        return fragment;\n    }\n\n    static createHolderForNode(o) {\n        let node = o.cloneNode(false);\n        node.innerFragment = BaseElement.createFragmentForNode(o);\n        return node;\n    }\n\n    static scanAndReplace(node) {\n        if (node.nodeName === \"TEMPLATE\") {\n            BaseElement.scanAndReplace(node.content);\n        }\n        else if (BaseElement.isAAElement(node)) {\n            // if(node.innerFragment) { return };\n            let holder = BaseElement.createHolderForNode(node);\n            node.replaceWith(holder);\n            node.innerFragment = holder.innerFragment;\n\n        } else\n            for (let i = 0; i < node.childNodes.length; i++) {\n                BaseElement.scanAndReplace(node.childNodes[i]);\n            }\n    }\n\n    constructor() {\n        super();\n        // console.log(this.nodeName+\"#\"+this.id, \"created\");\n        this._props = this.makePropertiesFromAttributes();\n    }\n\n    connectedCallback() {\n\n\n        // console.log(this.id, \" connected\");\n        this._attachedTimestamp = new Date().getTime();\n        this._debug = (this.debug === true) || (this.debug === null);\n        if (this.innerFragment) {\n\n            // I have commented BaseElement.scanAndReplace out because a shallow copy and an innerFragment\n            // is already created by BaseElement.copy for childNodes of this.innerFrament\n            // as they are appended to this element.\n            // BaseElement.scanAndReplace(this.innerFragment);\n            for (let i = 0; i < this.innerFragment.childNodes.length; i++) {\n                this.appendChild(BaseElement.copy(this.innerFragment.childNodes[i]));\n            }\n\n        }\n\n        this.setAttributeDefaultValues();\n    }\n\n    /**\n     * Properties are the member variables of the HTMLElement object.\n     * Attributes are the html tag's attributes.\n     * By convention, properties are in camelCase, e.g., someMembVariable\n     * while the corresponding attribute whould be hyphenated, e.g., some-member-variable.\n     * The purpose of this function is, based on the hyphenated attributes \n     * of the element, to generate corresponding camelCase properties\n     * \n     * Attribute names are provided by observedAttributes of the HTMLElement object,\n     * however objects that inherit from baseElement can also provide a more\n     * meaningful declaration, including datatype and default value, in \n     * a static get properties function, like so:\n     * \n     *  static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n            \"submit-button-text\":{\n                type:String,\n                value:\"submit\",\n                userDefined:true\n            },\n\n    \n     * This function also generates corresponding getter and setter functions\n     * for each property, so that properties and attributes always remain in sync\n     * with each other \n     */\n    makePropertiesFromAttributes() {\n\n        let ElementClass = customElements.get(this.tagName.toLowerCase());\n\n        let attr = ElementClass.observedAttributes;\n        if (!attr) return null;\n        let props = {};\n        for (let i = 0; i < attr.length; i++) {\n            let prop = this.toCamelCase(attr[i]);\n            props[prop] = attr[i];\n\n\n            if (typeof this[prop] != 'undefined') {\n                continue;\n            } else {\n\n                Object.defineProperty(this, prop, {\n                    get: () => {\n\n                        let result = this.getAttribute(attr[i]);\n                        if (result === 'true') { return true; }\n                        else if (result === 'false') { return false; }\n                        else { return result; }\n                    },\n                    set: (value) => {\n                        this.setAttribute(attr[i], value);\n                    }\n                });\n            }\n        }\n        return props;\n    }\n\n    toCamelCase(str) {\n        let words = str.split('-');\n        let result = words[0];\n        for (let i = 1; i < words.length; i++) {\n            result += words[i][0].toUpperCase() + words[i].substr(1);\n        }\n        return result;\n    }\n\n    toHyphenated(str) {\n        let result = '';\n        for (let i = 0; i < str.length; i++) {\n            let letter = str[i];\n            if (letter.toLowerCase() !== letter) {\n                // letter is uppercase\n                result += `-${letter.toLowerCase()}`;\n            } else {\n                result += letter;\n            }\n        }\n        return result;\n    }\n\n    setAttributeDefaultValues() {\n\n        let p = this.constructor.properties;\n        if (p) {\n            let keys = Object.keys(p);\n            for (let i = 0; i < keys.length; i++) {\n                // console.log(keys[i], p[keys[i]].value)\n\n                let prop = this.toCamelCase(keys[i]);\n                if ((typeof this[prop] === 'undefined') || (this[prop] === null)) {\n                    // this[prop] = p[keys[i]].value ;\n\n                    let val = this.getAttribute(keys[i]) || (p[keys[i]].value || null);\n\n\n\n                    if (val) this.setAttribute(keys[i], val);\n                    if (val === false) this.setAttribute(keys[i], val);\n                }\n\n            }\n        }\n\n    }\n\n    static copy(node) {\n        let nodeCopy;\n        if (BaseElement.isAAElement(node)) {\n\n            if (node.innerFragment) {\n                nodeCopy = node.cloneNode();\n                nodeCopy.innerFragment = BaseElement.createFragmentForNode(node.innerFragment);\n            } else {\n                nodeCopy = node.cloneNode();\n                nodeCopy.innerFragment = BaseElement.createFragmentForNode(node);\n            }\n        }\n        else {\n            nodeCopy = node.cloneNode(true);\n        }\n        return nodeCopy;\n    }\n\n    getAttributes() {\n        let result = {};\n        let attributes = Object.keys(this.constructor.properties);\n        for (let i = 0; i < attributes.length; i++) {\n            if (!this.constructor.properties[attributes[i]].userDefined) {\n                // users should need not be concerned\n                continue;\n            }\n\n            if ((typeof this.getAttribute(attributes[i]) !== 'undefined') && (this.getAttribute(attributes[i]) !== 'undefined')) {\n                if (this.constructor.properties[attributes[i]].value == this.getAttribute(attributes[i])) {\n                    // value is default value, no need to be part of specification\n                    continue;\n                }\n\n                result[attributes[i]] = this.getAttribute(attributes[i]);\n            }\n        }\n        return result;\n\n    }\n\n    toJSON() {\n        let result = {};\n        result[this.tagName.toLowerCase()] = this.getAttributes()\n        return result;\n    }\n\n    static nodeToJSON(node) {\n\n        if ((node.nodeType === document.TEXT_NODE) || (node.nodeType === document.COMMENT_NODE)) {\n            let result = {};\n            let text = node.textContent.replace(/\\n/g, ' ').replace(/\\t/g, ' ').replace(/\\s\\s+/g, ' ').trim();\n            if (text !== '') {\n                result[node.nodeName] = text;\n                return result;\n            }\n            else { return null }\n        }\n        else if (node.toJSON) {\n            return node.toJSON();\n\n\n        }\n\n\n        else {\n\n\n            try {\n\n                let result = {};\n\n                let attrs = node.getAttributeNames();\n                let attrObj = {};\n                for (let i = 0; i < attrs.length; i++) {\n                    attrObj[attrs[i]] = node.getAttribute(attrs[i]);\n                }\n                let childNodes = [];\n                for (let i = 0; i < node.childNodes.length; i++) {\n                    let el = BaseElement.nodeToJSON(node.childNodes[i]);\n                    if (el) {\n                        childNodes.push(BaseElement.nodeToJSON(node.childNodes[i]));\n                    }\n                }\n\n                result[node.tagName] = attrObj;\n                result[node.tagName].childNodes = childNodes;\n\n                return result;\n            } catch (e) {\n                console.error(e);\n                debugger;\n            }\n        }\n    }\n\n    toYAML() {\n        // return YAML.stringify(this.toJSON(), 4);\n        return jsyaml.dump(this.toJSON())\n    }\n\n\n    toJSL() {\n        return html2jsl.nodeToJSL(this);\n    }\n\n\n    \n\n\n    _dispatchDebugEvent(detail) {\n        if (this.debug) {\n            this.dispatchEvent(new CustomEvent('debugEvent', { detail, bubbles: true }));\n        }\n    }\n\n\n\n    _dispatchEndEvent(detail) {\n        //  use setTimeout to allow aaSequence.next() to return,\n        //  so that calls to aaSequence.next are not recursive\n        // setTimeout(()=>{\n        // debugger;\n        this.dispatchEvent(new CustomEvent('endEvent', { bubbles: true, detail }));\n        // },0);\n    }\n\n    _getParentSession() {\n        let _sessionElement = this;\n        while ((_sessionElement != null) && (_sessionElement.nodeName != 'AA-SESSION')) {\n            _sessionElement = _sessionElement.parentNode;\n        }\n        return _sessionElement;\n    }\n}\n\n\nif (!customElements.get('aa-base-element')) {\n    window.AANodeNames = window.AANodeNames || [];\n    window.AANodeNames.push('AA-BASE-ELEMENT');\n    customElements.define('aa-base-element', BaseElement);\n}\n\n\nwindow.nodeToJSON = BaseElement.nodeToJSON;\n","import BaseElement from '../aa-baseElement/baseElement.js';\nimport '../aa-choice-item/aa-choice-item.js';\n\nexport default class AACheckboxes extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            horizontal: {\n                type: Boolean,\n                value: false,\n                userDefined: true\n            },\n\n            vertical: {\n                type: Boolean,\n                value: true,\n                userDefined: true\n            },\n\n            name: {\n                type: String,\n                userDefined: true\n            },\n\n            value: {\n                type: String,\n                userDefined: false\n            },\n            \n\n\n\n        }\n    }\n\n    static get acceptsElements() {\n        return [\n            'aa-choice-item'\n        ]\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AACheckboxes.properties);\n    }\n\n\n    get value() {\n\n        let result = [];\n        if (this.boxes) {\n            for (let i = 0; i < this.boxes.length; i++) {\n                if (this.boxes[i].checked) {\n                    result.push(this.boxes[i].value);\n                }\n                else {\n                    result.push(null);\n                }\n            }\n\n        }\n        console.log(result);\n        return result\n    }\n\n    set value(val) {\n        this.setAttribute('value', val);\n        this.boxGroup.selected = val;\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.root.innerHTML = this.css + this.html;\n        this.boxes = [];\n        for (let i = 0; i < this.childNodes.length; i++) {\n            this.attachToShadowDomAccordingToKind(this.childNodes[i]);\n        }\n\n        this.boxes = this.root.querySelectorAll('paper-checkbox')\n\n        let val = this.getAttribute('value');\n        if (this.boxes) {\n            for (let i = 0; i < this.boxes.length; i++) {\n                if (this.boxes[i].value == val) {\n                    this.boxes[i].checked = true\n                }\n            }\n        }\n\n\n    }\n\n    attachToShadowDomAccordingToKind(node) {\n\n\n        if (!BaseElement.isAAElement(node)) {\n            this.root.appendChild(BaseElement.copy(node));\n        } else {\n            if (node.tagName === 'AA-CHOICE-ITEM') {\n                let child = document.createElement('paper-checkbox');\n                if (node.getAttribute('value')) {\n                    child.setAttribute('name', node.getAttribute('value'));\n                    child.setAttribute('value', node.getAttribute('value'));\n                } else {\n                    child.setAttribute('name', node.innerText.trim());\n                    child.setAttribute('value', node.innerText.trim());\n                }\n                if (!((this.horizontal === '') || (this.horizontal))) {\n                    child.style.display = 'block';\n                }\n                child.innerHTML = node.innerHTML;\n                this.root.appendChild(child);\n\n                // console.log('name: ', child.name);\n                this.boxes.push(child);\n            }\n        }\n    }\n\n    get html() {\n        return html``;\n    }\n\n    get css() {\n        return html`\n        <style>\n            paper-checkbox{\n                padding:12px;\n            }\n        </style>\n        \n        \n        `;\n    }\n\n    toJSON(){\n        let result = super.toJSON();\n        let children = [];\n        for(let i=0; i<this.children.length; i++){\n            children.push(this.children[i].toJSON());\n        }\n        \n        result[this.tagName.toLowerCase()].items = children;\n        return result; \n    }\n\n}\n\n\nBaseElement.registerAAElement('aa-checkboxes', AACheckboxes);","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AAChoiceItem extends BaseElement {\n\n\n    static get properties(){\n        return{\n            value:{\n                type:String,\n                userDefined:true\n            }           \n        }\n    }\n    static get observedAttributes() {\n        return [\n            'name',\n            'value'\n        ];\n    }\n\n    static get acceptsElements(){\n        return null;\n    }\n\n    constructor() {\n        super();\n\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n\n    }\n\n    toJSON(){\n        let result= super.toJSON();\n        result[this.tagName.toLowerCase()].label = this.innerHTML.trim();\n        return result;\n    }\n}\n\nBaseElement.registerAAElement('aa-choice-item', AAChoiceItem);","import BaseElement from './../aa-baseElement/baseElement.js';\nimport './aa-when/aa-when.js';\nimport './aa-otherwise/aa-otherwise.js';\n\n\nimport jsep from '../../lib/jsep/jsep.js';\nexport default class AAChoose extends BaseElement {\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n            \"should-run\":{\n                type:Boolean,\n                value:true,\n                userDefined:false\n            },\n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            }\n        }\n    }\n\n    static get acceptsElements(){\n        return[\n            \"aa-when\", \"aa-otherwise\"\n        ]\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAChoose.properties);\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = '<slot></slot>';\n        this.originalContent = this.innerHTML;\n    }\n\n\n    connectedCallback() {\n        this._shouldRun = (this.shouldRun === null) || (this.shouldRun === true);\n        this.sessionElement = this._getParentSession();\n\n        \n        if (this._shouldRun) {\n            if (typeof this.innerFragment !== 'undefined') {\n                BaseElement.scanAndReplace(this.innerFragment);\n                let nodes = this._getNodeToInstantiate();\n                if (nodes.length === 0) {\n                    this._dispatchEndEvent();\n                } else {\n                    let doesAnyNodeExpectWait = false;\n                    for (let i = 0; i < nodes.length; i++) {\n                        let node = nodes[i];\n                        if (typeof node !== 'undefined') {\n\n                            /**\n                             * certain elements, mainly the screen,\n                             * are synchronous and need to dispatch\n                             * their own \"end\" events.\n                             * \n                             * so look into the list of childNodes\n                             * contained into the part of the choose-when-otherwise\n                             * block that gets instantiated, and if you see\n                             * one with the property expectWait, don't tell\n                             * the sequence to move forward.\n                             * \n                             * Possibly the architecture for this needs to change,\n                             * and have the sequence specifically extract newly\n                             * produced nodes and insert them itself\n                            **/\n                           \n                            for(let j=0; j<node.childNodes.length;j++){\n                                \n                                // the element has not been attached\n                                // so we have to access the static properties getter\n                                // to get the default value for expectWait\n                                if(node.childNodes[j].constructor)\n                                if(node.childNodes[j].constructor.properties)\n                                if(node.childNodes[j].constructor.properties['expect-wait']){\n                                    doesAnyNodeExpectWait = true;\n                                }\n                            }\n\n                            this.parentNode.insertBefore(node, this.nextSibling);\n                        }\n                    }\n            \n                    /** \n                     * so here dispatch evdEvent only if you haven't encountered\n                     * something that has expectWait:true\n                     */\n                    if(!doesAnyNodeExpectWait) {\n                        this._dispatchEndEvent();\n                    }\n                }\n            }\n            else {\n                if (this.childNodes.length === 0) {\n                    this._dispatchEndEvent();\n                }\n            }\n        }\n        this.remove();\n    }\n\n    _getNodeToInstantiate() {\n        let nodesToReturn = [];\n        let nodeOtherwise = [];\n        let isChildTrue = false;\n        for (let i = 0; i < this.innerFragment.children.length; i++) {\n            let child = this.innerFragment.children[i];\n            if (child.nodeName === 'AA-WHEN') {\n                isChildTrue = this.evaluate(child);\n                if (isChildTrue) {\n                    nodesToReturn.push(BaseElement.copy(child).innerFragment);\n                }\n            } else if (child.nodeName === 'AA-OTHERWISE') {\n                nodeOtherwise.push(BaseElement.copy(child).innerFragment);\n            }\n        }\n        if (nodesToReturn.length === 0) {\n            return nodeOtherwise;\n        }\n        else {\n            return nodesToReturn;\n        }\n    }\n\n\n    evaluate(element) {\n        let test = element.getAttribute('test');\n        if ((test == null) || (test == '')) return null;\n        return this.evaluateTestExpression(test);\n    }\n\n    evaluateTestExpression(test) {\n\n        let expr = this.replaceExpressionIdentifiersWithValues(test);\n        // after replacing known variable names with their values in the string, test to see if the expression can be parsed\n        try {\n            var parseTree = jsep(expr);\n            if ((parseTree.left.type === 'Literal') && (parseTree.right.type === 'Literal')) {\n                return eval(expr);\n            }\n            else {\n                // there are still strings in the expression, which are unknown\n                // evaluate with values that the parseTreeProvides\n                return  eval(`${parseTree.left.value}${parseTree.operator}${parseTree.right.value}`);\n                //an exception should be raised\n                // throw 'unknown identifiers in expression : ' + expr;\n            }\n        } catch (e) {\n            console.error('parse error:', e);\n        }\n    }\n\n    replaceExpressionIdentifiersWithValues(expression, sessionElement) {\n        let session = sessionElement || this._getParentSession();\n        let result = expression.toUpperCase();\n\n        let originalIdentifiers = Object.keys(session.getDataDump());\n        let upperCaseIdentifiers = originalIdentifiers.map(s => s.toUpperCase());\n        for (let i in originalIdentifiers) {\n            let value = session.getData(originalIdentifiers[i]);\n            let finalValue = parseInt(value);\n            if (finalValue != value) {\n                if (value === 'null') { finalValue = 'null'; }\n                else if (value === 'true') { finalValue = 'true'; }\n                else if (value === 'false') { finalValue = 'false'; }\n                else finalValue = `\"${value}\"`;\n            }\n            let r = new RegExp(upperCaseIdentifiers[i], 'g');\n            result = result.replace(r, finalValue);\n        }\n        return result;\n    }\n}\n\nBaseElement.registerAAElement('aa-choose', AAChoose);\n\n","import BaseElement from '../../aa-baseElement/baseElement.js';\n\nexport default class AAOtherwise extends BaseElement {\n\n    static get acceptsElements(){\n        return null;\n    }\n    \n    constructor() {\n        super();\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n    }\n}\n\n\nBaseElement.registerAAElement('aa-otherwise', AAOtherwise);\n","import BaseElement from './../../aa-baseElement/baseElement.js';\n\nexport default class AAWhen extends BaseElement {\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:false\n            },\n            \"should-run\":{\n                type:Boolean,\n                value:true,\n                userDefined:false\n            },\n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            },\n            \"test\":{\n                type:String,\n                userDefined:true\n            }\n        }\n    }\n    static get acceptsElements(){\n        return null;\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAWhen.properties);\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = '<slot></slot>'\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n    }\n}\n\nBaseElement.registerAAElement('aa-when', AAWhen);\n\n","import BaseElement from '../aa-baseElement/baseElement.js';\n\nexport default class AAFunctionRandom extends BaseElement {\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n           \n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            },\n\n            \"value\":{\n                type:Number,\n                userDefined:false,\n            },\n\n            \"min\":{\n                type:Number,\n                userDefined:true,\n            },\n            \n            \"max\":{\n                type:Number,\n                userDefined:true,\n            },\n            \n\n        }\n    }\n\n    static get acceptsElements(){\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAFunctionRandom.properties);\n    }\n\n\n\n    constructor(){\n\n        super();\n    }\n\n    connectedCallback() {\n\n        let session = this._getParentSession();\n        this.value = this.getValue();\n        session.setData(this.name, this.value);\n        this._dispatchEndEvent({ autoDispatch: true });\n        if (!this.debug) { this.remove(); }\n    }\n\n    getValue() {\n        var parsedMin = parseFloat(this.min);\n        var parsedMax = parseFloat(this.max);\n        return this.getRandomInt(parsedMin, parsedMax);\n    }\n\n    getRandomInt(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min) + 0.5) + min;\n    }\n\n\n}\n\nBaseElement.registerAAElement('aa-function-random', AAFunctionRandom);\n\n","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AALabel extends BaseElement {\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.root.innerHTML = this.css + this.html;\n    }\n\n    get css(){\n        return html`\n            <style>\n                    :host{\n                        display:block;\n                        font-family: Roboto, Noto, sans-serif;\n                        font-weight:bold;\n                        margin-top:40px;\n                        margin-bottom:10px;\n                        \n                    }\n\n            </style>\n        `\n    }\n\n    get html(){\n        return `<slot></slot>`\n    }\n}\n\nBaseElement.registerAAElement('aa-label', AALabel);","import BaseElement from '../aa-baseElement/baseElement.js';\nimport '../aa-multiple-choice/aa-multiple-choice.js';\n\nexport default class AALikertScale extends BaseElement {\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n           \n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            },\n\n            \"value\":{\n                type:Number,\n                userDefined:false,\n            },\n\n            \"items\":{\n                type:String,\n                userDefined:true,\n            },\n\n            \"start-label\":{\n                type:String,\n                userDefined:true,\n                value:''\n            },\n\n            \"middle-label\":{\n                type:String,\n                userDefined:true,\n                value:''\n            },\n\n            \"end-label\":{\n                type:String,\n                userDefined:true,\n                value:''\n            },\n\n            \"start-item\":{\n                type:Number,\n                userDefined:true,\n                value:1\n            }\n            \n            \n\n        }\n    }\n\n    static get acceptsElements(){\n        return [];\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AALikertScale.properties);\n    }\n\n\n\n    constructor(){\n\n        super();\n\n        this.root = this.attachShadow({ mode: 'open' });\n\n\n    }\n\n    connectedCallback() {\n        super.connectedCallback();;\n\n        \n        this.root.innerHTML = this.html;\n\n        this.mChoice = this.root.querySelector(\"aa-multiple-choice\")\n        this.choiceItems = this.mChoice.choiceItems\n    }\n\n\n    getTags(){\n        \n        let c = '';\n        let start = `<div style=\"width:100px; white-space:nowrap\">${this.getAttribute(\"start-label\") || ''}</div>`\n        let middle = `<div style=\"width:100px; white-space:nowrap\">${this.getAttribute(\"middle-label\") || ''}</div>`\n        let end = `<div style=\"width:100px; white-space:nowrap\">${this.getAttribute(\"end-label\") || ''}</div>`\n        let placeholder = `<div style=\"width:50px\"></div>`;\n        \n\n\n        let items = parseInt(this.items)\n        for(let i=1; i<=items; i++){\n            \n            \n            \n            if(i==1) {\n                c+=start;\n            }\n            else if(i==Math.floor((items+1)/2)) {\n\n                c+=middle;\n            }\n            else if(i==items) {\n                c+=end;\n            } else{\n                c+=placeholder;\n            }\n\n            \n        }   \n\n        let result = `<div style=\"font-family: Roboto, Noto, sans-serif; width:100%; display:flex; justify-content:space-evenly; text-align:center\">${c}</div>`\n        return result;\n\n    }\n    get html(){\n        let items = ``;\n\n        let startItem = parseFloat(this.startItem)\n\n        if((!this.items)||(this.items===\"undefined\")) this.items = 5;\n        for(let i=0; i<this.items; i++){\n            items += `<aa-choice-item name=\"${i+startItem}\">${i+startItem}</aa-choice-item>`;\n        }\n        let result =  html`<div>\n                                <aa-multiple-choice horizontal=\"true\" name=\"${this.name}\">${items}</aa-multiple-choice>\n                                ${this.getTags()}    \n                            </div>\n                                `\n        \n        return result;\n    }\n\n\n    get value(){\n\n        if(this.mChoice)\n        {\n            return parseInt(this.mChoice.value);\n        } else{\n            return parseInt(this.getAttribute('value'));\n        }\n    }\n\n\n    getValue() {\n       return this.mChoice.value; \n    }\n\n \n\n\n}\n\nBaseElement.registerAAElement('aa-likert-scale', AALikertScale);\n\n","import BaseElement from './../aa-baseElement/baseElement.js'\n\n\n\nexport default class AAMemory extends BaseElement {\n\n    get observedAttributes(){\n        return [\"name\"];\n    }\n\n    constructor(){\n        super();\n    }\n\n    connectedCallback(){\n        \n    }\n\n    setData(name,value){\n        this.dataset[name] = value;\n    }\n\n    getData(name){\n        return this.dataset[this.toHyphenated(name)];\n    }\n}\n\nBaseElement.registerAAElement('aa-memory', AAMemory);\n","import BaseElement from '../aa-baseElement/baseElement.js';\nimport '../aa-choice-item/aa-choice-item.js';\n\nexport default class AAMultipleChoice extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            horizontal: {\n                type: Boolean,\n                value: false,\n                userDefined: true\n            },\n\n            vertical: {\n                type: Boolean,\n                value: true,\n                userDefined: true\n            },\n\n            name: {\n                type: String,\n                userDefined: true\n            },\n\n            value: {\n                type: String,\n                userDefined: true,\n\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return [\n            'aa-choice-item'\n        ]\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAMultipleChoice.properties);\n    }\n\n    get staticObject(){\n        return AAMultipleChoice;\n    }\n\n    get value() {\n\n        if (this.radioGroup) {\n            return this.radioGroup.selected;\n        }\n        return this.getAttribute('value');\n    }\n\n    set value(val) {\n\n        this.setAttribute('value', val);\n        this.radioGroup.selected = val;\n    }\n\n    constructor() {\n        super();\n\n        if(this.horizontal===''){\n            this.horizontal = true;\n        }\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = this.css + this.html;\n\n        this.radioGroup = this.root.querySelector('#radioGroup');\n        this.radioGroup.addEventListener('change', (e) => {\n            this.value = e.target.name;\n            console.log(this.value);\n        });\n\n    }\n\n    connectedCallback() {\n\n        super.connectedCallback();\n\n        this.choiceItems = [];\n        for (let i = 0; i < this.childNodes.length; i++) {\n            this.attachToShadowDomAccordingToKind(this.childNodes[i]);\n        }\n\n        if ((this.getAttribute('value'))&&(this.getAttribute('value')!=='undefined')) {\n            this.radioGroup.setAttribute('selected', this.getAttribute('value'));\n        }\n\n        this.style.display = 'block';\n    }\n\n    attachToShadowDomAccordingToKind(node) {\n\n        if (!BaseElement.isAAElement(node)) {\n            this.root.appendChild(BaseElement.copy(node));\n        } else {\n            if (node.tagName === 'AA-CHOICE-ITEM') {\n\n                let child = document.createElement('paper-radio-button');\n                if (node.getAttribute('value')) {\n                    child.setAttribute('name', node.getAttribute('value'));\n                } else {\n                    child.setAttribute('name', node.innerText.trim());\n                }\n                if (!((this.horizontal === '') || (this.horizontal))) {\n                    child.style.display = 'block';\n                }\n\n                child.innerHTML = node.innerHTML;\n                 \n                this.radioGroup.appendChild(child);\n                this.choiceItems.push(child);\n\n\n                if (((this.horizontal === '') || (this.horizontal))) {\n                    \n\n                    this.radioGroup.style.display='flex';\n                    this.radioGroup.style.justifyContent='space-evenly';\n\n                    // debugger;\n                    let d1 = child.shadowRoot.querySelector('#radioContainer');\n                    let d2 = child.shadowRoot.querySelector('#radioLabel');\n                    d2.style.textAlign = 'center';\n                    d2.style.marginLeft = '0px';\n                    d2.style.padding = '5px';\n                    // d2.style.whiteSpace = \"nowrap\";\n                    // d2.style.minWidth = \"50px\";\n                    // d2.style.maxWidth = \"90px\";\n                    let newDiv = document.createElement('div');\n                    newDiv.style.marginLeft = 'var(--paper-radio-button-label-spacing,10px)';\n                    newDiv.style.display='flex';\n                    newDiv.style.flexDirection='column';\n                    newDiv.style.alignItems = 'center';\n                    newDiv.style.textAlign = 'center';\n                    child.shadowRoot.appendChild(newDiv);\n                    newDiv.appendChild(d1);\n                    newDiv.appendChild(d2);\n \n                \n                } else {\n\n                }\n\n            }\n        }\n    }\n\n    get html() {\n        return html`<paper-radio-group id='radioGroup'></paper-radio-group>`;\n    }\n\n    get css() {\n        return ``;\n    }\n\n\n    toJSON(){\n        let result = super.toJSON();\n        if((result.horizontal)){\n            result.horizontal = true;\n        }\n\n        let children = [];\n        for(let i=0; i<this.children.length; i++){\n            children.push(this.children[i].toJSON());\n        }\n        \n        result[this.tagName.toLowerCase()].items = children;\n        return result; \n    }\n}\n\n\nBaseElement.registerAAElement('aa-multiple-choice', AAMultipleChoice);","import BaseElement from './../aa-baseElement/baseElement.js';\n\n\nexport default class AAScreen extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            \"submit-button-text\": {\n                type: String,\n                value: \"submit\",\n                userDefined: true\n            },\n\n            \"submit-button-hidden\": {\n                type: Boolean,\n                value: false,\n                userDefined: true\n            },\n\n            'expect-wait': {\n                type: Boolean,\n                userDefined: false,\n                value: true\n            },\n\n            'autohide': {\n                type: Boolean,\n                userDefined: false,\n                value: true\n            }\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null;\n    }\n    static get observedAttributes() {\n        return Object.keys(AAScreen.properties);\n    }\n\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        switch (name) {\n            case 'submit-button-text':\n                if (this.submitButton) { this.submitButton.innerHTML = newValue; }\n                break;\n            case 'submit-button-hidden':\n                if (this.submitButtonContainer) {\n                    if ((newValue !== true) || (newValue !== 'true')) {\n                        this.submitButtonContainer.style.display = 'block';\n                    } else {\n                        this.submitButtonContainer.style.display = 'none';\n                    }\n                }\n                break;\n        }\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        // this.expectWait = true;\n\n    }\n\n    connectedCallback() {\n\n        super.connectedCallback();\n\n\n\n        this.root.innerHTML = this.css + this.html;\n        this.submitButton = this.root.querySelector('.submitButton');\n        this.submitButtonContainer = this.root.querySelector('.submitButtonContainer');\n\n        if (this._started) { return; }\n        this._started = true;\n\n        if (this.submitButtonHidden) {\n            if (this.submitButtonContainer) {\n                this.submitButtonContainer.style.display = 'none';\n            }\n        }\n\n\n        this.root.querySelector('.submitButton').addEventListener('click', this.submitButtonClick.bind(this));\n\n\n    }\n\n\n    get css() {\n\n        return html`<style>\n                :host {\n                    display: block;\n                    height: fit-content;\n                    padding:20px;\n                    font-family:sans-serif;\n                }\n\n                .submitButtonContainer{\n                    text-align:right;\n                    justify-content: space-between; \n                    align-items:center;\n                    padding:20px;\n                }\n\n\n                paper-button.darkBlue {\n                    background-color: #0d47a1;\n                    color: white;\n                 }\n  \n         </style>`;\n    }\n\n    get html() {\n        return html`\n            <slot></slot>\n            <div id='userMessage'>\n            <div class='submitButtonContainer'>\n                <div>\n                    ${this.getSubmitButton()}\n            </div>\n                <div id='userMessage'></div>\n            </div>`;\n    }\n\n    getSubmitButton() {\n        let buttonText = this.submitButtonText || 'submit';\n        if (customElements.get('paper-button')) {\n            return html`<paper-button class='submitButton darkBlue' raised class='indigo'>${buttonText}</paper-button>`;\n        } else {\n            return html`<button class='submitButton'>${buttonText}</button>`;\n        }\n    }\n\n    submitButtonClick(e) {\n\n        let userMessage = this.querySelector('#userMessage');\n        if (this.hasChildrenThatDemandResponse()) {\n\n            userMessage.innerHTML = html`\n                    <div style='display:flex; align-items:center'> \n                        <div>please fill out the required fields</div> \n                            <div id='attention' style='color: red; font-size: 20px;  border: solid thin; border-radius: 50%; width: 20px;\n                                                margin-left:20px; height: 20px; \n                                                text-align: center;\n                                                padding: 5px;'>!</div></div>`;\n            return;\n        }\n\n        let valueSubmitEvent = new CustomEvent('valueSubmit', { bubbles: true, detail: { value: this.getValue() } });\n        this.dispatchEvent(valueSubmitEvent);\n        this._dispatchEndEvent(this.getValue());\n        if (typeof e.detail.callback != 'undefined') {\n            e.detail.callback(e);\n        }\n        if (this.autohide) {\n            this.hide();\n        }\n\n    }\n\n\n\n\n\n\n    hasChildrenThatDemandResponse() {\n\n        let aaChildren = this.getAAChildren(this);\n        let isMissingValues = false;\n        for (let i = 0; i < aaChildren.length; i++) {\n            if (aaChildren[i].mandatory) {\n                if (child.getValue() === null) {\n                    // console.log(child, 'demands response');\n                    // TODO : add a class to the child\n                    isMissingValues = true;\n                }\n            }\n        }\n\n        return isMissingValues;\n    }\n\n    getAAChildren() {\n        let result = [];\n        for (let i = 0; i < this.children.length; i++) {\n            if (BaseElement.isAAElement(this.children[i])) { result.push(this.children[i]); }\n        }\n        return result;\n    }\n\n\n\n    getChildrenValues(node, result) {\n        node = node || this;\n        result = result || [];\n        for (let i = 0; i < node.children.length; i++) {\n            let c = node.children[i];\n            if (c.getValue) {\n                result.push(c.getValue());\n            } else if (c.value) {\n                result.push({ [c.name]: c.value });\n            } else {\n                this.getChildrenValues(c, result);\n            }\n        }\n        return result;\n    }\n\n\n\n\n\n    getValue() {\n        let __meta = {\n            attachedTimestamp: this._attachedTimestamp,\n            submitTimestamp: new Date().getTime()\n        };\n        let result = this.getChildrenValues(this);\n        return result;\n    }\n\n    getValueWithKey() {\n        let result = {};\n        result[this.name] = this.getValue();\n        return result;\n    }\n\n\n    automate() {\n        for (let i = 0; i < this.children.length; i++) {\n            if (BaseElement.isAAElement(this.children[i])) {\n                if (typeof this.children[i].automate != 'undefined') {\n                    this.children[i].automate();\n                }\n            }\n        }\n        this.submitButtonClick();\n    }\n\n    hide() {\n        this.style.display = 'none';\n    }\n\n    show() {\n        this.style.display = 'block';\n    }\n}\n\nBaseElement.registerAAElement('aa-screen', AAScreen);\n\n","import BaseElement from '../../aa-baseElement/baseElement.js';\n\nexport default class AAJump extends BaseElement {\n\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n            \"goto\":{\n                type:String,\n                userDefined:true\n            }\n        }\n    }\n\n    static get acceptsElements(){\n        return []\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAJump.properties);\n    }\n\n    connectedCallback() {\n        this._dispatchEndEvent({ goto: this.goto, autoDispatch: true });\n        this.remove();\n    }\n}\n\nBaseElement.registerAAElement('aa-jump', AAJump);\n","import BaseElement from './../aa-baseElement/baseElement.js';\nimport './aa-jump/aa-jump.js';\n\n\n\nexport default class AASequence extends BaseElement {\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'write-into': {\n                type: String,\n                userDefined: true\n            },\n\n            'should-run':{\n                type:Boolean,\n                userDefined:true,\n                value:true\n            },\n\n            'debug': {\n                type: Boolean,\n                value: false,\n                userDefined: false\n            },\n            'type':{\n                type:String, //there should be an array of options type\n                userDefined: false\n            },\n            'stopped':{\n                type:Boolean,\n                userDefined:false\n            },\n\n        }\n    }\n\n    static get acceptsElements(){\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AASequence.properties);\n    }\n\n    constructor() {\n        super();\n        // this.root = this.attachShadow({ mode: 'open' });\n        // this.root.innerHTML = '<slot></slot>';\n    }\n    connectedCallback() {\n        this.addEventListener('endEvent', this.endEventListener.bind(this));\n        if ((this.shouldRun === null) || (this.shouldRun === true)) {\n            this.init()\n        };\n    }\n\n\n    get css() {\n        return html`\n            <style>\n                :host {\n                    display: block;\n                }\n            </style>\n        `\n    }\n\n    get html() {\n        return html`\n            <slot></slot>\n            <button id='nextButton' hidden></button>\n        `\n    }\n\n    init() {\n        this.stopped = false;\n        if (this.writeInto) {\n            this.target = document.querySelector(this.writeInto);\n        } else {\n            this.target = this;\n        }\n\n\n\n        if (typeof this.innerFragment === 'undefined') {\n            console.warn('.innerFragment is undefined');\n            this.restoreHeldNodes(this)\n            return;\n        }\n\n\n        this.sIndex = 0;\n        if (!this.stopped) { this.start() }\n    }\n\n    start() {\n        this.stopped = false;\n        this.next();\n    }\n\n    stop() {\n        this.stopped = true;\n    }\n\n\n\n\n    next(name) {\n\n        return new Promise((resolve, reject) => {\n\n\n            if (this.stopped) { return; }\n            if (this.sIndex >= this.innerFragment.childNodes.length) return null;\n\n            if (typeof name === 'string') {\n                for (let i = 0; i < this.innerFragment.childNodes.length; i++) {\n                    if (this.innerFragment.childNodes[i].getAttribute) if (this.innerFragment.childNodes[i].getAttribute('name') == name) {\n                        this.sIndex = i;\n                        break;\n                    }\n                }\n            }\n\n            let fragmentChild = this.innerFragment.childNodes[this.sIndex];\n\n            if(fragmentChild.nodeName==\"aa-screen\") debugger;\n            //  if the child is not an element just add it immediately \n            //  and move on to the next, there won't be a connectecCallback Function to execute anyway\n            while (fragmentChild.nodeType != Node.ELEMENT_NODE) {\n\n                let fragmentChildCopy = BaseElement.copy(fragmentChild);\n                this.target.appendChild(fragmentChildCopy);\n                this.currentNode = fragmentChildCopy;\n                this.sIndex++;\n                if (this.sIndex >= this.innerFragment.childNodes.length) { return; }\n                fragmentChild = this.innerFragment.childNodes[this.sIndex];\n            }\n            let fragmentChildCopy = BaseElement.copy(fragmentChild);\n            this.currentNode = fragmentChildCopy;\n            this.sIndex += 1;\n            if (!fragmentChildCopy._dispatchEndEvent) {\n                resolve(this.next());\n            } else {\n                this.target.appendChild(fragmentChildCopy);\n                setTimeout(() => resolve());\n            }\n        })\n    }\n\n    endEventListener(e) {\n        e.stopPropagation();\n        if (e.detail) {\n            if (e.detail.goto) { this.next(e.detail.goto); }\n            else if (e.detail.autoDispatch) { this.next(true); }\n            else { setTimeout(() => this.next(true)); }\n        } else {\n            setTimeout(() => this.next(true))\n        }\n    }\n\n\n\n\n\n\n\n    toSVG(){\n\n        \n        debugger;\n        let drawing = '';\n        \n        let x = 0;\n        let width = 30;\n        let height = 50;\n        for(let i=0; i<this.children.length; i++){\n            \n            drawing += html`<rect x=\"${x}\" y=\"0\" width=\"${width}\" height=\"${height}\" stroke=\"black\" fill=\"transparent\" stroke-width=\"5\"/>\n            <line x1=\"${x}\" y1=\"${height/2}\" x2=\"${x+20}\" y2=\"${height/2}\" stroke=\"#000\" stroke-width=\"5 marker-end=\"url(#arrowhead)\" />\n            \n            `\n            \n            \n\n        }\n        debugger;\n\n        let result = html`\n        <svg width=\"200\" height=\"250\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n    \n            <defs>\n                <marker id=\"arrowhead\" markerWidth=\"10\" markerHeight=\"7\" refX=\"0\" refY=\"3.5\" orient=\"auto\">\n                    <polygon points=\"0 0, 10 3.5, 0 7\" />\n                </marker>\n            </defs>\n\n            ${drawing}\n    </svg>`;\n\n        return result;\n    }\n\n\n\n\n\n\n}\n\nBaseElement.registerAAElement('aa-sequence', AASequence);\n\n\n","import BaseElement from './../aa-baseElement/baseElement.js'\n\nimport './../aa-memory/aa-memory.js'\nimport * as html2jsl from './../../lib/html2jsl/html2jsl.js'\n\nexport default class AASession extends BaseElement {\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'should-run': {\n                type: Boolean,\n                userDefined: true\n            },\n\n            'debug': {\n                type: Boolean,\n                value: false,\n                userDefined: false\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AASession.properties);\n    }\n\n\n\n    constructor() {\n        super();\n\n\n        this.myTemplate = document.createElement('template');\n        this.myTemplate.innerHTML = this.innerHTML;\n        this.innerHTML = '';\n\n        // this.root = this.attachShadow({ mode: 'closed' });\n        // this.root.innerHTML = '<template><slot></slot></template>'\n        this._mem = document.createElement('aa-memory');\n        this.addEventListener('valueSubmit', (e) => {\n\n\n            // e.stopPropagation();\n            let input = {\n                data: e.detail.value,\n                sessionID: this.sessionID,\n                sessionTimestamp: this.sessionTime,\n                sessionName: this.name,\n                variables: Object.keys(e.detail.value),\n            };\n            // TODO:  this._mem.saveReplyValue(e.detail.value, false);\n\n\n            let inputSubmitEvent = new CustomEvent('inputSubmit', { bubbles: true, detail: { input } });\n            this.dispatchEvent(inputSubmitEvent);\n            //  ema-participant-client needs to catch this and either send it to the server,\n            //  or store it locally if we are offline\n            //  A reason that ema-participant-client needs to do this, is because it cares\n            //  about identification tokens\n\n\n        })\n\n        this.addEventListener('endEvent', (e) => {\n            if (!this.debug) e.stopPropagation();\n            let sessionEndEvent = new CustomEvent('sessionEndEvent', { bubbles: true, detail: 'sessionEnd' });\n            this.dispatchEvent(sessionEndEvent);\n        })\n\n\n    }\n\n    myIdGenerator() {\n\n        return 0;\n    }\n\n    connectedCallback() {\n        // console.log(this.tagName+\"#\"+this.id,\"connected\");\n\n        this.sessionID = this.myIdGenerator();\n        this.sessionTime = new Date().getTime();\n        let sessionDatum = Object.keys(this.dataset);\n        for (let i in sessionDatum) {\n            this.setData(sessionDatum[i], this.dataset[sessionDatum[i]]);\n        }\n        if ((this.shouldRun === null) || (this.shouldRun === true)) {\n            this.run();\n        }\n    }\n\n\n    attachTemplateChildNodesToMyself(templateClone) {\n\n        while (templateClone.content.childNodes.length) {\n            //  if there's a direct template child, we want its children appended too\n            if (templateClone.content.childNodes[0].nodeName === \"TEMPLATE\") {\n                while (templateClone.content.childNodes[0].content.childNodes.length) {\n                    this.appendChild(templateClone.content.childNodes[0].content.childNodes[0]);\n                }\n                //  we are not appending the template element elsewhere \n                //  so throw it way so that the childnode count can be reduced\n                templateClone.content.childNodes[0].remove();\n            } else {\n                this.appendChild(templateClone.content.childNodes[0]);\n            }\n        }\n    }\n\n    run() {\n\n        let myTemplateClone = this.myTemplate.cloneNode(true);\n        BaseElement.scanAndReplace(myTemplateClone);\n        this.attachTemplateChildNodesToMyself(myTemplateClone);\n    }\n\n    getData(name) {\n        return this._mem.getData(name);\n    }\n    setData(name, value) {\n\n        return this._mem.setData(name, value);\n    }\n\n    getDataDump() {\n        return this._mem.dataset;\n    }\n\n\n    toJSON() {\n        // return super.toJSON();\n\n        let result = {};\n        result[this.tagName] = this.getAttributes()\n\n        let childNodes = [];\n        for (let i = 0; i < this.myTemplate.content.childNodes[0].content.childNodes.length; i++) {\n            let child = this.myTemplate.content.childNodes[0].content.childNodes[i]\n            let el = BaseElement.nodeToJSON(child);\n            if (el) {\n                childNodes.push(el);\n            }\n        }\n        result[this.tagName].childNodes = [{ \"template\": { childNodes: childNodes } }];\n        return result;\n\n    }\n\n    toJSL() {\n        let attrNames = this.getAttributeNames();\n        let attrObj = {};\n        for (let i = 0; i < attrNames.length; i++) {\n            if (this.getAttribute(attrNames[i]) !== 'undefined') {\n                attrObj[attrNames[i]] = this.getAttribute(attrNames[i]);\n            }\n        }\n\n        let argsStrings = [];\n        let childNodes = this.myTemplate.content.childNodes[0].content.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n            let addition = html2jsl.nodeToJSL(childNodes[i]);\n            if (addition) {\n                argsStrings.push(html2jsl.nodeToJSL(childNodes[i]));\n\n            }\n        }\n\n        console.log(argsStrings);\n\n        let tagName = this.tagName;\n        let templateString = html2jsl.formatJSLResult(\"TEMPLATE\", {}, argsStrings);\n        let final = html2jsl.formatJSLResult(\"AA_SESSION\", attrObj, [templateString]);\n\n        return final;\n    }\n\n\n\n\n    toSVG() {\n\n        let childNodes = this.myTemplate.content.childNodes[0].content.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n\n            console.log(childNodes[i].toSVG);\n\n            if (childNodes[i].toSVG) {\n                debugger;\n                return childNodes[i].toSVG();\n\n            }\n        }\n\n    }\n\n}\n\nBaseElement.registerAAElement('aa-session', AASession);\n\n\n\n\n\n\n\n","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AASlider extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'min': {\n                type: Number,\n                userDefined: true\n            },\n            'max': {\n                type: Number,\n                userDefined: true\n            },\n            'min-label': {\n                type: String,\n                userDefined: true\n            },\n            'max-label': {\n                type: String,\n                userDefined: true\n            },\n            'value': {\n                type: Number,\n                userDefined: false\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AASlider.properties);\n    }\n\n\n \n\n    get value() {\n        if (!this.inputItem) {\n            return this.getAttribute('value');\n        }\n        return this.inputItem.value;\n    }\n    set value(val) {\n        this.setAttribute('value', val);\n        if (this.inputItem) {\n            this.inputItem.value = val;\n        }\n\n    }\n\n    get minLabel() {\n        return this.getAttribute('min-label');\n    }\n\n    get maxLabel() {\n        return this.getAttribute('max-label');\n    }\n\n    set minLabel(val) {\n        this.setAttribute('min-label', val);\n        if (this.inputItem) {\n            this.inputItem.minLabel = val;\n        }\n    }\n\n    set maxLabel(val) {\n        this.setAttribute('max-label', val);\n        if (this.inputItem) {\n            this.inputItem.maxLabel = val;\n        }\n    }\n\n    set min(val) {\n        this.setAttribute('min', val);\n        if (this.inputItem) {\n            this.inputItem.min = val;\n        }\n    }\n\n    set max(val) {\n        this.setAttribute('max', val);\n        if (this.inputItem) {\n            this.inputItem.max = val;\n        }\n    }\n\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        \n        let innerHTML = this.css + `<div class='inputContainer'>${this.html}</div>`;\n        this.root.innerHTML = innerHTML;\n\n        let minLabel = this.minLabel;\n        let maxLabel = this.maxLabel;\n        // let min = this.min || 0;\n        // let max = this.max || 100;\n        let value = this.value || (this.min + this.max)/2;\n        this.inputItem = this.root.querySelector('.inputItem');\n        this.minLabelItem = this.root.querySelector('.minLabel');\n        this.maxLabelItem = this.root.querySelector('.maxLabel');\n        \n        if (minLabel) { this.minLabelItem.innerHTML = minLabel;}\n        if (maxLabel) { this.maxLabelItem.innerHTML = maxLabel;}\n        if (value) { this.inputItem.value = value; }\n        \n        this.inputItem.addEventListener('change', (e) => {\n            this.value = e.target.value;\n        });\n    }\n\n\n\n    connectedCallback() {\n        super.connectedCallback();\n\n\n    }\n\n    get css() {\n        return `<style>\n        :host{\n            display:block;\n            overflow:hidden;        \n        }\n        </style>\n        `;\n    }\n\n    get html() {\n        let inputElement = customElements.get('paper-slider')\n            ? `<paper-slider style=\"width:100%\" class='inputItem min=${this.min} max=${this.max}'></paper-slider>`\n            : `<input style=\"width:100%\" type=\"range\" class=\"inputItem\" min=\"${this.min}\" max=\"${this.max}\" value=\"${(this.max+this.min)/2}\">`;\n        \n\n        let source = html`\n        <div>${inputElement}</div>\n        <div style=\"display:flex; justify-content:space-between\">\n            <div class=\"minLabel\">${this.minLabel || ''}</div>\n            <div style=\"text-align:right\" class=\"maxLabel\">${this.maxLabel || ''}</div>\n        </div>\n        `\n        return source;\n    }\n   \n\n}\n\nBaseElement.registerAAElement('aa-slider', AASlider);","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AATextAnswer extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'long': {\n                type: Boolean,\n                userDefined: true\n            },\n            label: {\n                type: String,\n                userDefined: true\n            },\n            'value': {\n                type: String,\n                userDefined: false\n            },\n            'type':{\n                type: String,\n                userDefined: true,\n                value:\"text\",\n                valuesAllowed: [\"date\", \"datetime\", \"datetime-local\", \"email\", \"number\", \"password\", \"tel\", \"text\", \"time\" ]\n            }\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AATextAnswer.properties);\n    }\n\n\n    changeInputItem(type) {\n        if (type === 'long') {\n            let value = this.value;\n            let label = this.label;\n            this.inputItem = customElements.get('paper-textarea') ?\n                document.createElement('paper-textarea') : document.createElement('textarea');\n            this.inputItem.value = value;\n            this.inputItem.label = label;\n            this.inputItem.classList.add('inputItem');\n            this.fixBugInPaperTextarea(this.inputItem);\n            this.inputItem.addEventListener('change', (e) => {\n                this.value = e.target.value;\n            })\n            this.root.querySelector('.inputItem').replaceWith(this.inputItem);\n        } else {\n            let value = this.value;\n            let label = this.label;\n            this.inputItem = customElements.get('paper-input') ?\n                document.createElement('paper-input') : document.createElement('input');\n            this.inputItem.value = value;\n            this.inputItem.label = label;\n            this.inputItem.classList.add('inputItem');\n            this.inputItem.addEventListener('change', (e) => {\n                this.value = e.target.value;\n            })\n            this.root.querySelector('.inputItem').replaceWith(this.inputItem);\n        }\n    }\n\n\n    get value() {\n        if (!this.inputItem) {\n            return this.getAttribute('value');\n        }\n        return this.inputItem.value;\n    }\n    set value(val) {\n        this.setAttribute('value', val);\n        if (this.inputItem) {\n            this.inputItem.value = val;\n        }\n\n    }\n\n    get label() {\n        return this.getAttribute('label');\n    }\n\n    set label(val) {\n        this.setAttribute('label', val);\n        if (this.inputItem) {\n            this.inputItem.label = val;\n        }\n    }\n\n    set long(val) {\n        this.setAttribute('long', val);\n        if (val) {\n            this.changeInputItem('long');\n        } else {\n            this.changeInputItem('short');\n        }\n    }\n\n    get long() {\n        return this.getAttribute('long');\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        let html = (this.long || (this.long === '')) ? this.longHtml : this.html;\n\n        this.root.innerHTML = this.css + `<div class='inputContainer'>${html}</div>`;\n\n        let label = this.label;\n        let value = this.value;\n        this.inputItem = this.root.querySelector('.inputItem');\n        if (label) { this.inputItem.label = label; }\n        if (value) { this.inputItem.value = value; }\n        this.fixBugInPaperTextarea(this.inputItem);\n\n        this.inputItem.addEventListener('change', (e) => {\n            this.value = e.target.value;\n        });\n    }\n\n\n    fixBugInPaperTextarea(inputItem) {\n        // solves issue documented here: https://github.com/PolymerElements/paper-input/issues/125\n\n        setTimeout(() => {\n            if (inputItem.tagName === 'PAPER-TEXTAREA') {\n                inputItem.root.childNodes[2].children[1].textarea.style.overflow = 'hidden';\n                let width = window.getComputedStyle(this.root.querySelector('.inputContainer')).width;\n\n                inputItem.root.childNodes[2].style.width = width;\n                inputItem.addEventListener('focus', (e) => {\n                    let width = window.getComputedStyle(this.root.querySelector('.inputContainer')).width;\n                    inputItem.root.childNodes[2].style.width = width;\n                })\n\n                window.addEventListener('resize', () => {\n                    inputItem.root.childNodes[2].style.width = '';\n                    setTimeout(() => {\n                        let width = window.getComputedStyle(this.root.querySelector('.inputContainer')).width;\n                        inputItem.root.childNodes[2].style.width = width;\n                    }, 100);\n\n                })\n            };\n        }, 0);\n\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n\n\n    }\n\n    get css() {\n        return `<style>\n        :host{\n            display:block;\n            overflow:hidden;        \n        }\n        paper-textarea textarea {\n           overflow:hidden;\n        }\n        </style>`;\n    }\n\n    get html() {\n        let inputElement = customElements.get('paper-input')\n            ? `<paper-input type='${this.type}' class='inputItem'></paper-input>`\n            : `<input type='${this.type}' class='inputItem'>`;\n        return html`${inputElement}`\n    }\n    get longHtml() {\n        let inputElement = customElements.get('paper-input')\n            ? `<paper-textarea class='inputItem'></paper-input>`\n            : `<textarea class='inputItem'></textarea`;\n        return html`${inputElement}`\n    }\n\n}\n\nBaseElement.registerAAElement('aa-text-answer', AATextAnswer);","import BaseElement from './../aa-baseElement/baseElement.js'\nexport default class AAVariable extends BaseElement {\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'value': {\n                type: String,\n                userDefined: true\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return []\n    }\n\n    static get observedAttributes() {\n\n        return Object.keys(AAVariable.properties);\n\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n        let session = this._getParentSession();\n        session.setData(this.name, this.value);\n        this._dispatchEndEvent({autoDispatch:true});\n        if(!this.debug) {this.remove();}\n    };\n\n\n}\n\nBaseElement.registerAAElement('aa-variable', AAVariable);\n\n","// import '../dist/paper-polymer.js';\nimport BaseElement from './customElements/aa-baseElement/baseElement.js';\nimport AAVariable from './customElements/aa-variable/aa-variable.js';\nimport AAFunctionRandom from './customElements/aa-function/aa-function-random.js';\nimport AAChoose from './customElements/aa-choose/aa-choose.js';\nimport AAWhen from './customElements/aa-choose/aa-when/aa-when.js';\nimport AAOtherwise from './customElements/aa-choose/aa-otherwise/aa-otherwise.js';\nimport AAMemory from './customElements/aa-memory/aa-memory.js';\nimport AAScreen from './customElements/aa-screen/aa-screen.js';\nimport AASequence from './customElements/aa-sequence/aa-sequence.js';\nimport AASession from './customElements/aa-session/aa-session.js';\nimport AATextAnswer from './customElements/aa-text-answer/aa-text-answer.js';\nimport AAMultipleChoice from './customElements/aa-multiple-choice/aa-multiple-choice.js';\nimport AAChoiceItem from './customElements/aa-choice-item/aa-choice-item.js';\nimport AACheckboxes from './customElements/aa-checkboxes/aa-checkboxes.js';\nimport AALikertScale from './customElements/aa-likert-scale/aa-likert-scale.js';\nimport AASlider from './customElements/aa-slider/aa-slider.js';\nimport AAAffectGrid from './customElements/aa-affect-grid/aa-affect-grid.js';\nimport AALabel from './customElements/aa-label/aa-label.js';\n// debugger;\n\n\nexport {\n    BaseElement, AAVariable, AAFunctionRandom,\n    AAChoose, AAWhen, AAOtherwise, AAMemory, AAScreen,\n    AASequence, AASession, AATextAnswer,\n    AAChoiceItem, AAMultipleChoice, AACheckboxes, AALikertScale,\n    AASlider, AAAffectGrid, AALabel\n}","\nexport function nodeToJSL(node) {\n\n    if ((node.nodeType === document.TEXT_NODE)||(node.nodeType === document.COMMENT_NODE)) {\n        let result = node.textContent.replace(/\\n/g, ' ').replace(/\\t/g, ' ').replace(/\\s\\s+/g, ' ').trim();\n        if (result === '') {\n            return undefined;\n        } else { return `\"${result}\"`; }\n\n    } else {\n\n        \n        let attrNames = node.getAttributeNames();\n        let attrObj = {};\n        for (let i = 0; i < attrNames.length; i++) {\n            if (node.getAttribute(attrNames[i]) !== 'undefined') {\n                attrObj[attrNames[i]] = node.getAttribute(attrNames[i]);\n            }\n        }\n\n        let argsStrings = [];\n        for (let i = 0; i < node.childNodes.length; i++) {\n            let addition = nodeToJSL(node.childNodes[i]);\n            if (addition) {\n                argsStrings.push(nodeToJSL(node.childNodes[i]));\n\n            }\n        }\n\n        let tagName = node.tagName.replace(/\\-/g, '_');\n        return formatJSLResult(tagName, attrObj, argsStrings);\n\n    }\n\n}\n\n\n\nfunction tab(s) {\n    let result = s.replace(/\\n/g, '\\n\\t');\n    if (result[0] !== '\\n') { result = `\\t${result}`; }\n    return result;\n}\n\n\nfunction getAttrsAsString(attrObj) {\n\n    let keys = Object.keys(attrObj);\n    if(keys.length>3){\n        return JSON.stringify(attrObj, null, 2)\n    }else {\n        return JSON.stringify(attrObj);\n    }\n}\n\nfunction getArgsString(argsStrings) {\n    let result = '';\n    for (let i = 0; i < argsStrings.length; i++) {\n        result += `${argsStrings[i]}`;\n        if (i !== argsStrings.length - 1) {result += ',\\n';}\n    }\n    return result;\n}\n\nexport function formatJSLResult(tagName, attrObj, argsStrings) {\n    let attrs = getAttrsAsString(attrObj);\n    let args = getArgsString(argsStrings);\n    let isArgsMultiline = /\\n/.test(args);\n\n    //decide if newline for attributes:\n    let attrParam;\n    let newLineForAttrs = false;\n    //do they exist\n    let attrsExist = attrs !== '{}';\n    if (attrsExist) {\n        //do they contain newlines\n        if (attrs.indexOf('\\n') != -1) {\n            newLineForAttrs = true;\n        } else {\n            //are they long\n            if (attrs.length > 50) {\n                newLineForAttrs = true;\n            }\n        }\n        if (newLineForAttrs) {\n            attrParam = `\\n${tab(attrs)}${argsStrings.length ? ',' : ''}`;\n        }\n        else {\n            attrParam = `${attrs}${argsStrings.length ? ',' : ''}`;\n        }\n\n    } else {\n        //attributes don't exist;\n        attrParam = '';\n    }\n    // let argsParam;\n    // let newLineForArgs = false;\n    let result = `${tagName}( ${attrParam}${isArgsMultiline ? `\\n${tab(args)}\\n` : `${attrsExist ? ' ' : ''}${args}`} )`;\n    return result;\n}\n","/**\r\n * this is a modified version of the original jsep \r\n * which if the root parameter is undefined,\r\n * the jsep object returned so as to be exported   \r\n **/ \r\n\r\n\r\n//     JavaScript Expression Parser (JSEP) 0.3.4\r\n//     JSEP may be freely distributed under the MIT License\r\n//     http://jsep.from.so/\r\n\r\n/*global module: true, exports: true, console: true */\r\nexport default (function (root) {\r\n\t'use strict';\r\n\t// Node Types\r\n\t// ----------\r\n\t\r\n\t// This is the full set of types that any JSEP node can be.\r\n\t// Store them here to save space when minified\r\n\tvar COMPOUND = 'Compound',\r\n\t\tIDENTIFIER = 'Identifier',\r\n\t\tMEMBER_EXP = 'MemberExpression',\r\n\t\tLITERAL = 'Literal',\r\n\t\tTHIS_EXP = 'ThisExpression',\r\n\t\tCALL_EXP = 'CallExpression',\r\n\t\tUNARY_EXP = 'UnaryExpression',\r\n\t\tBINARY_EXP = 'BinaryExpression',\r\n\t\tLOGICAL_EXP = 'LogicalExpression',\r\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\r\n\t\tARRAY_EXP = 'ArrayExpression',\r\n\r\n\t\tPERIOD_CODE = 46, // '.'\r\n\t\tCOMMA_CODE  = 44, // ','\r\n\t\tSQUOTE_CODE = 39, // single quote\r\n\t\tDQUOTE_CODE = 34, // double quotes\r\n\t\tOPAREN_CODE = 40, // (\r\n\t\tCPAREN_CODE = 41, // )\r\n\t\tOBRACK_CODE = 91, // [\r\n\t\tCBRACK_CODE = 93, // ]\r\n\t\tQUMARK_CODE = 63, // ?\r\n\t\tSEMCOL_CODE = 59, // ;\r\n\t\tCOLON_CODE  = 58, // :\r\n\r\n\t\tthrowError = function(message, index) {\r\n\t\t\tvar error = new Error(message + ' at character ' + index);\r\n\t\t\terror.index = index;\r\n\t\t\terror.description = message;\r\n\t\t\tthrow error;\r\n\t\t},\r\n\r\n\t// Operations\r\n\t// ----------\r\n\r\n\t// Set `t` to `true` to save space (when minified, not gzipped)\r\n\t\tt = true,\r\n\t// Use a quickly-accessible map to store all of the unary operators\r\n\t// Values are set to `true` (it really doesn't matter)\r\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\r\n\t// Also use a map for the binary operations but set their values to their\r\n\t// binary precedence for quick reference:\r\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\r\n\t\tbinary_ops = {\r\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\r\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\r\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7,\r\n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\r\n\t\t\t'+': 9, '-': 9,\r\n\t\t\t'*': 10, '/': 10, '%': 10\r\n\t\t},\r\n\t// Get return the longest key length of any object\r\n\t\tgetMaxKeyLen = function(obj) {\r\n\t\t\tvar max_len = 0, len;\r\n\t\t\tfor(var key in obj) {\r\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\r\n\t\t\t\t\tmax_len = len;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn max_len;\r\n\t\t},\r\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\r\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\r\n\t// Literals\r\n\t// ----------\r\n\t// Store the values to return for the various literals we may encounter\r\n\t\tliterals = {\r\n\t\t\t'true': true,\r\n\t\t\t'false': false,\r\n\t\t\t'null': null\r\n\t\t},\r\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\r\n\t\tthis_str = 'this',\r\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\r\n\t\tbinaryPrecedence = function(op_val) {\r\n\t\t\treturn binary_ops[op_val] || 0;\r\n\t\t},\r\n\t// Utility function (gets called from multiple places)\r\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\r\n\t\tcreateBinaryExpression = function (operator, left, right) {\r\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\r\n\t\t\treturn {\r\n\t\t\t\ttype: type,\r\n\t\t\t\toperator: operator,\r\n\t\t\t\tleft: left,\r\n\t\t\t\tright: right\r\n\t\t\t};\r\n\t\t},\r\n\t\t// `ch` is a character code in the next three functions\r\n\t\tisDecimalDigit = function(ch) {\r\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\r\n\t\t},\r\n\t\tisIdentifierStart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\t\tisIdentifierPart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n\t\t\t\t\t(ch >= 48 && ch <= 57) || // 0...9\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\r\n\t\t// Parsing\r\n\t\t// -------\r\n\t\t// `expr` is a string with the passed in expression\r\n\t\tjsep = function(expr) {\r\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\r\n\t\t\t// All of the gobbles below will modify `index` as we move along\r\n\t\t\tvar index = 0,\r\n\t\t\t\tcharAtFunc = expr.charAt,\r\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\r\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\r\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\r\n\t\t\t\tlength = expr.length,\r\n\r\n\t\t\t\t// Push `index` up to the next non-space character\r\n\t\t\t\tgobbleSpaces = function() {\r\n\t\t\t\t\tvar ch = exprICode(index);\r\n\t\t\t\t\t// space or tab\r\n\t\t\t\t\twhile(ch === 32 || ch === 9 || ch === 10 || ch === 13) {\r\n\t\t\t\t\t\tch = exprICode(++index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\r\n\t\t\t\tgobbleExpression = function() {\r\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\r\n\t\t\t\t\t\tconsequent, alternate;\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\r\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tconsequent = gobbleExpression();\r\n\t\t\t\t\t\tif(!consequent) {\r\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\talternate = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!alternate) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\r\n\t\t\t\t\t\t\t\ttest: test,\r\n\t\t\t\t\t\t\t\tconsequent: consequent,\r\n\t\t\t\t\t\t\t\talternate: alternate\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrowError('Expected :', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn test;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\r\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\r\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\r\n\t\t\t\t// then, return that binary operation\r\n\t\t\t\tgobbleBinaryOp = function() {\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tvar  to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\r\n\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\t// Don't accept a binary op when it is an identifier.\r\n\t\t\t\t\t\t// Binary ops that start with a identifier-valid character must be followed\r\n\t\t\t\t\t\t// by a non identifier-part valid character\r\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check) && (\r\n\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\r\n\t\t\t\t\t\t\t(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\r\n\t\t\t\t\t\t)) {\r\n\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\treturn to_check;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// This function is responsible for gobbling an individual expression,\r\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\r\n\t\t\t\tgobbleBinaryExpression = function() {\r\n\t\t\t\t\tvar node, biop, prec, stack, biop_info, left, right, i;\r\n\r\n\t\t\t\t\t// First, try to get the leftmost thing\r\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\r\n\t\t\t\t\tleft = gobbleToken();\r\n\t\t\t\t\tbiop = gobbleBinaryOp();\r\n\r\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\r\n\t\t\t\t\tif(!biop) {\r\n\t\t\t\t\t\treturn left;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\r\n\t\t\t\t\t// precedence structure\r\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\r\n\r\n\t\t\t\t\tright = gobbleToken();\r\n\t\t\t\t\tif(!right) {\r\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstack = [left, biop_info, right];\r\n\r\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\r\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\r\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\r\n\r\n\t\t\t\t\t\tif(prec === 0) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\r\n\r\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\r\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\r\n\t\t\t\t\t\t\tright = stack.pop();\r\n\t\t\t\t\t\t\tbiop = stack.pop().value;\r\n\t\t\t\t\t\t\tleft = stack.pop();\r\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\r\n\t\t\t\t\t\t\tstack.push(node);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnode = gobbleToken();\r\n\t\t\t\t\t\tif(!node) {\r\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstack.push(biop_info, node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ti = stack.length - 1;\r\n\t\t\t\t\tnode = stack[i];\r\n\t\t\t\t\twhile(i > 1) {\r\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\r\n\t\t\t\t\t\ti -= 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// An individual part of a binary expression:\r\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\r\n\t\t\t\tgobbleToken = function() {\r\n\t\t\t\t\tvar ch, to_check, tc_len;\r\n\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch = exprICode(index);\r\n\r\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\r\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\r\n\t\t\t\t\t\treturn gobbleNumericLiteral();\r\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\r\n\t\t\t\t\t\t// Single or double quotes\r\n\t\t\t\t\t\treturn gobbleStringLiteral();\r\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\r\n\t\t\t\t\t\treturn gobbleArray();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\r\n\t\t\t\t\t\ttc_len = to_check.length;\r\n\t\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\t// Don't accept an unary op when it is an identifier.\r\n\t\t\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\r\n\t\t\t\t\t\t// by a non identifier-part valid character\r\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check) && (\r\n\t\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\r\n\t\t\t\t\t\t\t\t(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\r\n\t\t\t\t\t\t\t)) {\r\n\t\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\r\n\t\t\t\t\t\t\t\t\toperator: to_check,\r\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\r\n\t\t\t\t\t\t\t\t\tprefix: true\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\r\n\t\t\t\t\t\t\t// `foo`, `bar.baz`\r\n\t\t\t\t\t\t\treturn gobbleVariable();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\r\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\r\n\t\t\t\tgobbleNumericLiteral = function() {\r\n\t\t\t\t\tvar number = '', ch, chCode;\r\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\r\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tchCode = exprICode(index);\r\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\r\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\r\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\r\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\r\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\r\n\t\t\t\t\t\tthrowError('Unexpected period', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: parseFloat(number),\r\n\t\t\t\t\t\traw: number\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\r\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\r\n\t\t\t\tgobbleStringLiteral = function() {\r\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\tif(ch === quote) {\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if(ch === '\\\\') {\r\n\t\t\t\t\t\t\t// Check for all of the common escape codes\r\n\t\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\t\tswitch(ch) {\r\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\r\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\r\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\r\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\r\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\r\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\r\n\t\t\t\t\t\t\t\tdefault : str += ch;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstr += ch;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(!closed) {\r\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: str,\r\n\t\t\t\t\t\traw: quote + str + quote\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles only identifiers\r\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\r\n\t\t\t\t// Also, this function checks if that identifier is a literal:\r\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\r\n\t\t\t\tgobbleIdentifier = function() {\r\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\r\n\r\n\t\t\t\t\tif(isIdentifierStart(ch)) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprICode(index);\r\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tidentifier = expr.slice(start, index);\r\n\r\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\t\tvalue: literals[identifier],\r\n\t\t\t\t\t\t\traw: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if(identifier === this_str) {\r\n\t\t\t\t\t\treturn { type: THIS_EXP };\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: IDENTIFIER,\r\n\t\t\t\t\t\t\tname: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\r\n\t\t\t\t// or array literal. This function also assumes that the opening character\r\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\r\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\r\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\r\n\t\t\t\tgobbleArguments = function(termination) {\r\n\t\t\t\t\tvar ch_i, args = [], node, closed = false;\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnode = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\targs.push(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!closed) {\r\n\t\t\t\t\t\tthrowError('Expected ' + String.fromCharCode(termination), index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn args;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\r\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\r\n\t\t\t\t// It also gobbles function calls:\r\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\r\n\t\t\t\tgobbleVariable = function() {\r\n\t\t\t\t\tvar ch_i, node;\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tnode = gobbleGroup();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode = gobbleIdentifier();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: false,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: true,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\r\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\r\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\r\n\t\t\t\t\t\t\t\tcallee: node\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\r\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\r\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\r\n\t\t\t\t// then the expression probably doesn't have a `)`\r\n\t\t\t\tgobbleGroup = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\tvar node = gobbleExpression();\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unclosed (', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\r\n\t\t\t\t// and then tries to gobble the expressions as arguments.\r\n\t\t\t\tgobbleArray = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: ARRAY_EXP,\r\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\tnodes = [], ch_i, node;\r\n\r\n\t\t\twhile(index < length) {\r\n\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\r\n\t\t\t\t// separators\r\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\r\n\t\t\t\t\tindex++; // ignore separators\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Try to gobble each expression individually\r\n\t\t\t\t\tif((node = gobbleExpression())) {\r\n\t\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\r\n\t\t\t\t\t// the expression passed in probably has too much\r\n\t\t\t\t\t} else if(index < length) {\r\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If there's only one expression just try returning the expression\r\n\t\t\tif(nodes.length === 1) {\r\n\t\t\t\treturn nodes[0];\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: COMPOUND,\r\n\t\t\t\t\tbody: nodes\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t// To be filled in by the template\r\n\tjsep.version = '0.3.4';\r\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\r\n\r\n\t/**\r\n\t * @method jsep.addUnaryOp\r\n\t * @param {string} op_name The name of the unary op to add\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addUnaryOp = function(op_name) {\r\n\t\tmax_unop_len = Math.max(op_name.length, max_unop_len);\r\n\t\tunary_ops[op_name] = t; return this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addBinaryOp\r\n\t * @param {string} op_name The name of the binary op to add\r\n\t * @param {number} precedence The precedence of the binary op (can be a float)\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addBinaryOp = function(op_name, precedence) {\r\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\r\n\t\tbinary_ops[op_name] = precedence;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addLiteral\r\n\t * @param {string} literal_name The name of the literal to add\r\n\t * @param {*} literal_value The value of the literal\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addLiteral = function(literal_name, literal_value) {\r\n\t\tliterals[literal_name] = literal_value;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeUnaryOp\r\n\t * @param {string} op_name The name of the unary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeUnaryOp = function(op_name) {\r\n\t\tdelete unary_ops[op_name];\r\n\t\tif(op_name.length === max_unop_len) {\r\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllUnaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllUnaryOps = function() {\r\n\t\tunary_ops = {};\r\n\t\tmax_unop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeBinaryOp\r\n\t * @param {string} op_name The name of the binary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeBinaryOp = function(op_name) {\r\n\t\tdelete binary_ops[op_name];\r\n\t\tif(op_name.length === max_binop_len) {\r\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllBinaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllBinaryOps = function() {\r\n\t\tbinary_ops = {};\r\n\t\tmax_binop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeLiteral\r\n\t * @param {string} literal_name The name of the literal to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeLiteral = function(literal_name) {\r\n\t\tdelete literals[literal_name];\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllLiterals\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllLiterals = function() {\r\n\t\tliterals = {};\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// In desktop environments, have a way to restore the old value for `jsep`\r\n\tif (typeof exports === 'undefined') {\r\n\r\n\t\tif(!root){\r\n\t\t\treturn  jsep;\r\n\t\t}\r\n\t\tvar old_jsep = root.jsep;\r\n\t\t// The star of the show! It's a function!\r\n\t\troot.jsep = jsep;\r\n\t\t// And a courteous function willing to move out of the way for other similarly-named objects!\r\n\t\tjsep.noConflict = function() {\r\n\t\t\tif(root.jsep === jsep) {\r\n\t\t\t\troot.jsep = old_jsep;\r\n\t\t\t}\r\n\t\t\treturn jsep;\r\n\t\t};\r\n\t} else {\r\n\t\t// In Node.JS environments\r\n\t\tif (typeof module !== 'undefined' && module.exports) {\r\n\t\t\texports = module.exports = jsep;\r\n\t\t} else {\r\n\t\t\texports.parse = jsep;\r\n\t\t}\r\n\t}\r\n}(this));\r\n","/* js-yaml 3.14.0 https://github.com/nodeca/js-yaml */\n\nexport default (function (f) { if (typeof exports === \"object\" && typeof module !== \"undefined\") { module.exports = f() } else if (typeof define === \"function\" && define.amd) { define([], f) } else { var g; if (typeof window !== \"undefined\") { g = window } else if (typeof global !== \"undefined\") { g = global } else if (typeof self !== \"undefined\") { g = self } else { g = this } g.jsyaml = f() } })(function () {\n   return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = \"function\" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error(\"Cannot find module '\" + i + \"'\"); throw a.code = \"MODULE_NOT_FOUND\", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n\n      var loader = require('./js-yaml/loader');\n      var dumper = require('./js-yaml/dumper');\n\n\n      function deprecated(name) {\n        return function () {\n          throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n        };\n      }\n\n\n      module.exports.Type = require('./js-yaml/type');\n      module.exports.Schema = require('./js-yaml/schema');\n      module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');\n      module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');\n      module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\n      module.exports.load = loader.load;\n      module.exports.loadAll = loader.loadAll;\n      module.exports.safeLoad = loader.safeLoad;\n      module.exports.safeLoadAll = loader.safeLoadAll;\n      module.exports.dump = dumper.dump;\n      module.exports.safeDump = dumper.safeDump;\n      module.exports.YAMLException = require('./js-yaml/exception');\n\n      // Deprecated schema names from JS-YAML 2.0.x\n      module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n      // Deprecated functions from JS-YAML 1.x.x\n      module.exports.scan = deprecated('scan');\n      module.exports.parse = deprecated('parse');\n      module.exports.compose = deprecated('compose');\n      module.exports.addConstructor = deprecated('addConstructor');\n\n    }, { \"./js-yaml/dumper\": 3, \"./js-yaml/exception\": 4, \"./js-yaml/loader\": 5, \"./js-yaml/schema\": 7, \"./js-yaml/schema/core\": 8, \"./js-yaml/schema/default_full\": 9, \"./js-yaml/schema/default_safe\": 10, \"./js-yaml/schema/failsafe\": 11, \"./js-yaml/schema/json\": 12, \"./js-yaml/type\": 13 }], 2: [function (require, module, exports) {\n      'use strict';\n\n\n      function isNothing(subject) {\n        return (typeof subject === 'undefined') || (subject === null);\n      }\n\n\n      function isObject(subject) {\n        return (typeof subject === 'object') && (subject !== null);\n      }\n\n\n      function toArray(sequence) {\n        if (Array.isArray(sequence)) return sequence;\n        else if (isNothing(sequence)) return [];\n\n        return [sequence];\n      }\n\n\n      function extend(target, source) {\n        var index, length, key, sourceKeys;\n\n        if (source) {\n          sourceKeys = Object.keys(source);\n\n          for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n            key = sourceKeys[index];\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n\n      function repeat(string, count) {\n        var result = '', cycle;\n\n        for (cycle = 0; cycle < count; cycle += 1) {\n          result += string;\n        }\n\n        return result;\n      }\n\n\n      function isNegativeZero(number) {\n        return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n      }\n\n\n      module.exports.isNothing = isNothing;\n      module.exports.isObject = isObject;\n      module.exports.toArray = toArray;\n      module.exports.repeat = repeat;\n      module.exports.isNegativeZero = isNegativeZero;\n      module.exports.extend = extend;\n\n    }, {}], 3: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable no-use-before-define*/\n\n      var common = require('./common');\n      var YAMLException = require('./exception');\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\n      var _toString = Object.prototype.toString;\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      var CHAR_TAB = 0x09; /* Tab */\n      var CHAR_LINE_FEED = 0x0A; /* LF */\n      var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */\n      var CHAR_SPACE = 0x20; /* Space */\n      var CHAR_EXCLAMATION = 0x21; /* ! */\n      var CHAR_DOUBLE_QUOTE = 0x22; /* \" */\n      var CHAR_SHARP = 0x23; /* # */\n      var CHAR_PERCENT = 0x25; /* % */\n      var CHAR_AMPERSAND = 0x26; /* & */\n      var CHAR_SINGLE_QUOTE = 0x27; /* ' */\n      var CHAR_ASTERISK = 0x2A; /* * */\n      var CHAR_COMMA = 0x2C; /* , */\n      var CHAR_MINUS = 0x2D; /* - */\n      var CHAR_COLON = 0x3A; /* : */\n      var CHAR_EQUALS = 0x3D; /* = */\n      var CHAR_GREATER_THAN = 0x3E; /* > */\n      var CHAR_QUESTION = 0x3F; /* ? */\n      var CHAR_COMMERCIAL_AT = 0x40; /* @ */\n      var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */\n      var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\n      var CHAR_GRAVE_ACCENT = 0x60; /* ` */\n      var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */\n      var CHAR_VERTICAL_LINE = 0x7C; /* | */\n      var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */\n\n      var ESCAPE_SEQUENCES = {};\n\n      ESCAPE_SEQUENCES[0x00] = '\\\\0';\n      ESCAPE_SEQUENCES[0x07] = '\\\\a';\n      ESCAPE_SEQUENCES[0x08] = '\\\\b';\n      ESCAPE_SEQUENCES[0x09] = '\\\\t';\n      ESCAPE_SEQUENCES[0x0A] = '\\\\n';\n      ESCAPE_SEQUENCES[0x0B] = '\\\\v';\n      ESCAPE_SEQUENCES[0x0C] = '\\\\f';\n      ESCAPE_SEQUENCES[0x0D] = '\\\\r';\n      ESCAPE_SEQUENCES[0x1B] = '\\\\e';\n      ESCAPE_SEQUENCES[0x22] = '\\\\\"';\n      ESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\n      ESCAPE_SEQUENCES[0x85] = '\\\\N';\n      ESCAPE_SEQUENCES[0xA0] = '\\\\_';\n      ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n      ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\n      var DEPRECATED_BOOLEANS_SYNTAX = [\n        'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n        'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n      ];\n\n      function compileStyleMap(schema, map) {\n        var result, keys, index, length, tag, style, type;\n\n        if (map === null) return {};\n\n        result = {};\n        keys = Object.keys(map);\n\n        for (index = 0, length = keys.length; index < length; index += 1) {\n          tag = keys[index];\n          style = String(map[tag]);\n\n          if (tag.slice(0, 2) === '!!') {\n            tag = 'tag:yaml.org,2002:' + tag.slice(2);\n          }\n          type = schema.compiledTypeMap['fallback'][tag];\n\n          if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n            style = type.styleAliases[style];\n          }\n\n          result[tag] = style;\n        }\n\n        return result;\n      }\n\n      function encodeHex(character) {\n        var string, handle, length;\n\n        string = character.toString(16).toUpperCase();\n\n        if (character <= 0xFF) {\n          handle = 'x';\n          length = 2;\n        } else if (character <= 0xFFFF) {\n          handle = 'u';\n          length = 4;\n        } else if (character <= 0xFFFFFFFF) {\n          handle = 'U';\n          length = 8;\n        } else {\n          throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n        }\n\n        return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n      }\n\n      function State(options) {\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.indent = Math.max(1, (options['indent'] || 2));\n        this.noArrayIndent = options['noArrayIndent'] || false;\n        this.skipInvalid = options['skipInvalid'] || false;\n        this.flowLevel = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n        this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n        this.sortKeys = options['sortKeys'] || false;\n        this.lineWidth = options['lineWidth'] || 80;\n        this.noRefs = options['noRefs'] || false;\n        this.noCompatMode = options['noCompatMode'] || false;\n        this.condenseFlow = options['condenseFlow'] || false;\n\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.explicitTypes = this.schema.compiledExplicit;\n\n        this.tag = null;\n        this.result = '';\n\n        this.duplicates = [];\n        this.usedDuplicates = null;\n      }\n\n      // Indents every line in a string. Empty lines (\\n only) are not indented.\n      function indentString(string, spaces) {\n        var ind = common.repeat(' ', spaces),\n          position = 0,\n          next = -1,\n          result = '',\n          line,\n          length = string.length;\n\n        while (position < length) {\n          next = string.indexOf('\\n', position);\n          if (next === -1) {\n            line = string.slice(position);\n            position = length;\n          } else {\n            line = string.slice(position, next + 1);\n            position = next + 1;\n          }\n\n          if (line.length && line !== '\\n') result += ind;\n\n          result += line;\n        }\n\n        return result;\n      }\n\n      function generateNextLine(state, level) {\n        return '\\n' + common.repeat(' ', state.indent * level);\n      }\n\n      function testImplicitResolving(state, str) {\n        var index, length, type;\n\n        for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n          type = state.implicitTypes[index];\n\n          if (type.resolve(str)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      // [33] s-white ::= s-space | s-tab\n      function isWhitespace(c) {\n        return c === CHAR_SPACE || c === CHAR_TAB;\n      }\n\n      // Returns true if the character can be printed without escaping.\n      // From YAML 1.2: \"any allowed characters known to be non-printable\n      // should also be escaped. [However,] This isn’t mandatory\"\n      // Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n      function isPrintable(c) {\n        return (0x00020 <= c && c <= 0x00007E)\n          || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n          || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n          || (0x10000 <= c && c <= 0x10FFFF);\n      }\n\n      // [34] ns-char ::= nb-char - s-white\n      // [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n      // [26] b-char  ::= b-line-feed | b-carriage-return\n      // [24] b-line-feed       ::=     #xA    /* LF */\n      // [25] b-carriage-return ::=     #xD    /* CR */\n      // [3]  c-byte-order-mark ::=     #xFEFF\n      function isNsChar(c) {\n        return isPrintable(c) && !isWhitespace(c)\n          // byte-order-mark\n          && c !== 0xFEFF\n          // b-char\n          && c !== CHAR_CARRIAGE_RETURN\n          && c !== CHAR_LINE_FEED;\n      }\n\n      // Simplified test for values allowed after the first character in plain style.\n      function isPlainSafe(c, prev) {\n        // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n        // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n        return isPrintable(c) && c !== 0xFEFF\n          // - c-flow-indicator\n          && c !== CHAR_COMMA\n          && c !== CHAR_LEFT_SQUARE_BRACKET\n          && c !== CHAR_RIGHT_SQUARE_BRACKET\n          && c !== CHAR_LEFT_CURLY_BRACKET\n          && c !== CHAR_RIGHT_CURLY_BRACKET\n          // - \":\" - \"#\"\n          // /* An ns-char preceding */ \"#\"\n          && c !== CHAR_COLON\n          && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n      }\n\n      // Simplified test for values allowed as the first character in plain style.\n      function isPlainSafeFirst(c) {\n        // Uses a subset of ns-char - c-indicator\n        // where ns-char = nb-char - s-white.\n        return isPrintable(c) && c !== 0xFEFF\n          && !isWhitespace(c) // - s-white\n          // - (c-indicator ::=\n          // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n          && c !== CHAR_MINUS\n          && c !== CHAR_QUESTION\n          && c !== CHAR_COLON\n          && c !== CHAR_COMMA\n          && c !== CHAR_LEFT_SQUARE_BRACKET\n          && c !== CHAR_RIGHT_SQUARE_BRACKET\n          && c !== CHAR_LEFT_CURLY_BRACKET\n          && c !== CHAR_RIGHT_CURLY_BRACKET\n          // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n          && c !== CHAR_SHARP\n          && c !== CHAR_AMPERSAND\n          && c !== CHAR_ASTERISK\n          && c !== CHAR_EXCLAMATION\n          && c !== CHAR_VERTICAL_LINE\n          && c !== CHAR_EQUALS\n          && c !== CHAR_GREATER_THAN\n          && c !== CHAR_SINGLE_QUOTE\n          && c !== CHAR_DOUBLE_QUOTE\n          // | “%” | “@” | “`”)\n          && c !== CHAR_PERCENT\n          && c !== CHAR_COMMERCIAL_AT\n          && c !== CHAR_GRAVE_ACCENT;\n      }\n\n      // Determines whether block indentation indicator is required.\n      function needIndentIndicator(string) {\n        var leadingSpaceRe = /^\\n* /;\n        return leadingSpaceRe.test(string);\n      }\n\n      var STYLE_PLAIN = 1,\n        STYLE_SINGLE = 2,\n        STYLE_LITERAL = 3,\n        STYLE_FOLDED = 4,\n        STYLE_DOUBLE = 5;\n\n      // Determines which scalar styles are possible and returns the preferred style.\n      // lineWidth = -1 => no limit.\n      // Pre-conditions: str.length > 0.\n      // Post-conditions:\n      //    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n      //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n      //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n      function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n        var i;\n        var char, prev_char;\n        var hasLineBreak = false;\n        var hasFoldableLine = false; // only checked if shouldTrackWidth\n        var shouldTrackWidth = lineWidth !== -1;\n        var previousLineBreak = -1; // count the first line correctly\n        var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n        if (singleLineOnly) {\n          // Case: no block styles.\n          // Check for disallowed characters to rule out plain and single.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n            if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          }\n        } else {\n          // Case: block styles permitted.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n            if (char === CHAR_LINE_FEED) {\n              hasLineBreak = true;\n              // Check if any line can be folded.\n              if (shouldTrackWidth) {\n                hasFoldableLine = hasFoldableLine ||\n                  // Foldable line = too long, and not more-indented.\n                  (i - previousLineBreak - 1 > lineWidth &&\n                    string[previousLineBreak + 1] !== ' ');\n                previousLineBreak = i;\n              }\n            } else if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          }\n          // in case the end is missing a \\n\n          hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n            (i - previousLineBreak - 1 > lineWidth &&\n              string[previousLineBreak + 1] !== ' '));\n        }\n        // Although every style can represent \\n without escaping, prefer block styles\n        // for multiline, since they're more readable and they don't add empty lines.\n        // Also prefer folding a super-long line.\n        if (!hasLineBreak && !hasFoldableLine) {\n          // Strings interpretable as another type have to be quoted;\n          // e.g. the string 'true' vs. the boolean true.\n          return plain && !testAmbiguousType(string)\n            ? STYLE_PLAIN : STYLE_SINGLE;\n        }\n        // Edge case: block indentation indicator can only have one digit.\n        if (indentPerLevel > 9 && needIndentIndicator(string)) {\n          return STYLE_DOUBLE;\n        }\n        // At this point we know block styles are valid.\n        // Prefer literal style unless we want to fold.\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n      }\n\n      // Note: line breaking/folding is implemented for only the folded style.\n      // NB. We drop the last trailing newline (if any) of a returned block scalar\n      //  since the dumper adds its own newline. This always works:\n      //    • No ending newline => unaffected; already using strip \"-\" chomping.\n      //    • Ending newline    => removed then restored.\n      //  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n      function writeScalar(state, string, level, iskey) {\n        state.dump = (function () {\n          if (string.length === 0) {\n            return \"''\";\n          }\n          if (!state.noCompatMode &&\n            DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n            return \"'\" + string + \"'\";\n          }\n\n          var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n          // As indentation gets deeper, let the width decrease monotonically\n          // to the lower bound min(state.lineWidth, 40).\n          // Note that this implies\n          //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n          //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n          // This behaves better than a constant minimum width which disallows narrower options,\n          // or an indent threshold which causes the width to suddenly increase.\n          var lineWidth = state.lineWidth === -1\n            ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n          // Without knowing if keys are implicit/explicit, assume implicit for safety.\n          var singleLineOnly = iskey\n            // No block styles in flow mode.\n            || (state.flowLevel > -1 && level >= state.flowLevel);\n          function testAmbiguity(string) {\n            return testImplicitResolving(state, string);\n          }\n\n          switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n            case STYLE_PLAIN:\n              return string;\n            case STYLE_SINGLE:\n              return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n            case STYLE_LITERAL:\n              return '|' + blockHeader(string, state.indent)\n                + dropEndingNewline(indentString(string, indent));\n            case STYLE_FOLDED:\n              return '>' + blockHeader(string, state.indent)\n                + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n            case STYLE_DOUBLE:\n              return '\"' + escapeString(string) + '\"';\n            default:\n              throw new YAMLException('impossible error: invalid scalar style');\n          }\n        }());\n      }\n\n      // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n      function blockHeader(string, indentPerLevel) {\n        var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n        // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n        var clip = string[string.length - 1] === '\\n';\n        var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n        var chomp = keep ? '+' : (clip ? '' : '-');\n\n        return indentIndicator + chomp + '\\n';\n      }\n\n      // (See the note for writeScalar.)\n      function dropEndingNewline(string) {\n        return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n      }\n\n      // Note: a long line without a suitable break point will exceed the width limit.\n      // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n      function foldString(string, width) {\n        // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n        // unless they're before or after a more-indented line, or at the very\n        // beginning or end, in which case $k$ maps to $k$.\n        // Therefore, parse each chunk as newline(s) followed by a content line.\n        var lineRe = /(\\n+)([^\\n]*)/g;\n\n        // first line (possibly an empty line)\n        var result = (function () {\n          var nextLF = string.indexOf('\\n');\n          nextLF = nextLF !== -1 ? nextLF : string.length;\n          lineRe.lastIndex = nextLF;\n          return foldLine(string.slice(0, nextLF), width);\n        }());\n        // If we haven't reached the first content line yet, don't add an extra \\n.\n        var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n        var moreIndented;\n\n        // rest of the lines\n        var match;\n        while ((match = lineRe.exec(string))) {\n          var prefix = match[1], line = match[2];\n          moreIndented = (line[0] === ' ');\n          result += prefix\n            + (!prevMoreIndented && !moreIndented && line !== ''\n              ? '\\n' : '')\n            + foldLine(line, width);\n          prevMoreIndented = moreIndented;\n        }\n\n        return result;\n      }\n\n      // Greedy line breaking.\n      // Picks the longest line under the limit each time,\n      // otherwise settles for the shortest line over the limit.\n      // NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n      function foldLine(line, width) {\n        if (line === '' || line[0] === ' ') return line;\n\n        // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n        var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n        var match;\n        // start is an inclusive index. end, curr, and next are exclusive.\n        var start = 0, end, curr = 0, next = 0;\n        var result = '';\n\n        // Invariants: 0 <= start <= length-1.\n        //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n        // Inside the loop:\n        //   A match implies length >= 2, so curr and next are <= length-2.\n        while ((match = breakRe.exec(line))) {\n          next = match.index;\n          // maintain invariant: curr - start <= width\n          if (next - start > width) {\n            end = (curr > start) ? curr : next; // derive end <= length-2\n            result += '\\n' + line.slice(start, end);\n            // skip the space that was output as \\n\n            start = end + 1;                    // derive start <= length-1\n          }\n          curr = next;\n        }\n\n        // By the invariants, start <= length-1, so there is something left over.\n        // It is either the whole string or a part starting from non-whitespace.\n        result += '\\n';\n        // Insert a break if the remainder is too long and there is a break available.\n        if (line.length - start > width && curr > start) {\n          result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n        } else {\n          result += line.slice(start);\n        }\n\n        return result.slice(1); // drop extra \\n joiner\n      }\n\n      // Escapes a double-quoted string.\n      function escapeString(string) {\n        var result = '';\n        var char, nextChar;\n        var escapeSeq;\n\n        for (var i = 0; i < string.length; i++) {\n          char = string.charCodeAt(i);\n          // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n          if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n            nextChar = string.charCodeAt(i + 1);\n            if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n              // Combine the surrogate pair and store it escaped.\n              result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n              // Advance index one extra since we already used that char here.\n              i++; continue;\n            }\n          }\n          escapeSeq = ESCAPE_SEQUENCES[char];\n          result += !escapeSeq && isPrintable(char)\n            ? string[i]\n            : escapeSeq || encodeHex(char);\n        }\n\n        return result;\n      }\n\n      function writeFlowSequence(state, level, object) {\n        var _result = '',\n          _tag = state.tag,\n          index,\n          length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level, object[index], false, false)) {\n            if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = '[' + _result + ']';\n      }\n\n      function writeBlockSequence(state, level, object, compact) {\n        var _result = '',\n          _tag = state.tag,\n          index,\n          length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level + 1, object[index], true, true)) {\n            if (!compact || index !== 0) {\n              _result += generateNextLine(state, level);\n            }\n\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              _result += '-';\n            } else {\n              _result += '- ';\n            }\n\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '[]'; // Empty sequence if no valid values.\n      }\n\n      function writeFlowMapping(state, level, object) {\n        var _result = '',\n          _tag = state.tag,\n          objectKeyList = Object.keys(object),\n          index,\n          length,\n          objectKey,\n          objectValue,\n          pairBuffer;\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n          pairBuffer = '';\n          if (index !== 0) pairBuffer += ', ';\n\n          if (state.condenseFlow) pairBuffer += '\"';\n\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level, objectKey, false, false)) {\n            continue; // Skip this pair because of invalid key;\n          }\n\n          if (state.dump.length > 1024) pairBuffer += '? ';\n\n          pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n          if (!writeNode(state, level, objectValue, false, false)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          pairBuffer += state.dump;\n\n          // Both key and value are valid.\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = '{' + _result + '}';\n      }\n\n      function writeBlockMapping(state, level, object, compact) {\n        var _result = '',\n          _tag = state.tag,\n          objectKeyList = Object.keys(object),\n          index,\n          length,\n          objectKey,\n          objectValue,\n          explicitPair,\n          pairBuffer;\n\n        // Allow sorting keys so that the output file is deterministic\n        if (state.sortKeys === true) {\n          // Default sorting\n          objectKeyList.sort();\n        } else if (typeof state.sortKeys === 'function') {\n          // Custom sort function\n          objectKeyList.sort(state.sortKeys);\n        } else if (state.sortKeys) {\n          // Something is wrong\n          throw new YAMLException('sortKeys must be a boolean or a function');\n        }\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          pairBuffer = '';\n\n          if (!compact || index !== 0) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n            continue; // Skip this pair because of invalid key.\n          }\n\n          explicitPair = (state.tag !== null && state.tag !== '?') ||\n            (state.dump && state.dump.length > 1024);\n\n          if (explicitPair) {\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              pairBuffer += '?';\n            } else {\n              pairBuffer += '? ';\n            }\n          }\n\n          pairBuffer += state.dump;\n\n          if (explicitPair) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += ':';\n          } else {\n            pairBuffer += ': ';\n          }\n\n          pairBuffer += state.dump;\n\n          // Both key and value are valid.\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n      }\n\n      function detectType(state, object, explicit) {\n        var _result, typeList, index, length, type, style;\n\n        typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n        for (index = 0, length = typeList.length; index < length; index += 1) {\n          type = typeList[index];\n\n          if ((type.instanceOf || type.predicate) &&\n            (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n            (!type.predicate || type.predicate(object))) {\n\n            state.tag = explicit ? type.tag : '?';\n\n            if (type.represent) {\n              style = state.styleMap[type.tag] || type.defaultStyle;\n\n              if (_toString.call(type.represent) === '[object Function]') {\n                _result = type.represent(object, style);\n              } else if (_hasOwnProperty.call(type.represent, style)) {\n                _result = type.represent[style](object, style);\n              } else {\n                throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n              }\n\n              state.dump = _result;\n            }\n\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      // Serializes `object` and writes it to global `result`.\n      // Returns true on success, or false on invalid object.\n      //\n      function writeNode(state, level, object, block, compact, iskey) {\n        state.tag = null;\n        state.dump = object;\n\n        if (!detectType(state, object, false)) {\n          detectType(state, object, true);\n        }\n\n        var type = _toString.call(state.dump);\n\n        if (block) {\n          block = (state.flowLevel < 0 || state.flowLevel > level);\n        }\n\n        var objectOrArray = type === '[object Object]' || type === '[object Array]',\n          duplicateIndex,\n          duplicate;\n\n        if (objectOrArray) {\n          duplicateIndex = state.duplicates.indexOf(object);\n          duplicate = duplicateIndex !== -1;\n        }\n\n        if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n          compact = false;\n        }\n\n        if (duplicate && state.usedDuplicates[duplicateIndex]) {\n          state.dump = '*ref_' + duplicateIndex;\n        } else {\n          if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n            state.usedDuplicates[duplicateIndex] = true;\n          }\n          if (type === '[object Object]') {\n            if (block && (Object.keys(state.dump).length !== 0)) {\n              writeBlockMapping(state, level, state.dump, compact);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowMapping(state, level, state.dump);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object Array]') {\n            var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n            if (block && (state.dump.length !== 0)) {\n              writeBlockSequence(state, arrayLevel, state.dump, compact);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowSequence(state, arrayLevel, state.dump);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object String]') {\n            if (state.tag !== '?') {\n              writeScalar(state, state.dump, level, iskey);\n            }\n          } else {\n            if (state.skipInvalid) return false;\n            throw new YAMLException('unacceptable kind of an object to dump ' + type);\n          }\n\n          if (state.tag !== null && state.tag !== '?') {\n            state.dump = '!<' + state.tag + '> ' + state.dump;\n          }\n        }\n\n        return true;\n      }\n\n      function getDuplicateReferences(object, state) {\n        var objects = [],\n          duplicatesIndexes = [],\n          index,\n          length;\n\n        inspectNode(object, objects, duplicatesIndexes);\n\n        for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n          state.duplicates.push(objects[duplicatesIndexes[index]]);\n        }\n        state.usedDuplicates = new Array(length);\n      }\n\n      function inspectNode(object, objects, duplicatesIndexes) {\n        var objectKeyList,\n          index,\n          length;\n\n        if (object !== null && typeof object === 'object') {\n          index = objects.indexOf(object);\n          if (index !== -1) {\n            if (duplicatesIndexes.indexOf(index) === -1) {\n              duplicatesIndexes.push(index);\n            }\n          } else {\n            objects.push(object);\n\n            if (Array.isArray(object)) {\n              for (index = 0, length = object.length; index < length; index += 1) {\n                inspectNode(object[index], objects, duplicatesIndexes);\n              }\n            } else {\n              objectKeyList = Object.keys(object);\n\n              for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n                inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n              }\n            }\n          }\n        }\n      }\n\n      function dump(input, options) {\n        options = options || {};\n\n        var state = new State(options);\n\n        if (!state.noRefs) getDuplicateReferences(input, state);\n\n        if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n        return '';\n      }\n\n      function safeDump(input, options) {\n        return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n      }\n\n      module.exports.dump = dump;\n      module.exports.safeDump = safeDump;\n\n    }, { \"./common\": 2, \"./exception\": 4, \"./schema/default_full\": 9, \"./schema/default_safe\": 10 }], 4: [function (require, module, exports) {\n      // YAML error class. http://stackoverflow.com/questions/8458984\n      //\n      'use strict';\n\n      function YAMLException(reason, mark) {\n        // Super constructor\n        Error.call(this);\n\n        this.name = 'YAMLException';\n        this.reason = reason;\n        this.mark = mark;\n        this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n        // Include stack trace in error object\n        if (Error.captureStackTrace) {\n          // Chrome and NodeJS\n          Error.captureStackTrace(this, this.constructor);\n        } else {\n          // FF, IE 10+ and Safari 6+. Fallback for others\n          this.stack = (new Error()).stack || '';\n        }\n      }\n\n\n      // Inherit from Error\n      YAMLException.prototype = Object.create(Error.prototype);\n      YAMLException.prototype.constructor = YAMLException;\n\n\n      YAMLException.prototype.toString = function toString(compact) {\n        var result = this.name + ': ';\n\n        result += this.reason || '(unknown reason)';\n\n        if (!compact && this.mark) {\n          result += ' ' + this.mark.toString();\n        }\n\n        return result;\n      };\n\n\n      module.exports = YAMLException;\n\n    }, {}], 5: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable max-len,no-use-before-define*/\n\n      var common = require('./common');\n      var YAMLException = require('./exception');\n      var Mark = require('./mark');\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n      var CONTEXT_FLOW_IN = 1;\n      var CONTEXT_FLOW_OUT = 2;\n      var CONTEXT_BLOCK_IN = 3;\n      var CONTEXT_BLOCK_OUT = 4;\n\n\n      var CHOMPING_CLIP = 1;\n      var CHOMPING_STRIP = 2;\n      var CHOMPING_KEEP = 3;\n\n\n      var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n      var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n      var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n      var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\n      function _class(obj) { return Object.prototype.toString.call(obj); }\n\n      function is_EOL(c) {\n        return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n      }\n\n      function is_WHITE_SPACE(c) {\n        return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n      }\n\n      function is_WS_OR_EOL(c) {\n        return (c === 0x09/* Tab */) ||\n          (c === 0x20/* Space */) ||\n          (c === 0x0A/* LF */) ||\n          (c === 0x0D/* CR */);\n      }\n\n      function is_FLOW_INDICATOR(c) {\n        return c === 0x2C/* , */ ||\n          c === 0x5B/* [ */ ||\n          c === 0x5D/* ] */ ||\n          c === 0x7B/* { */ ||\n          c === 0x7D/* } */;\n      }\n\n      function fromHexCode(c) {\n        var lc;\n\n        if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n          return c - 0x30;\n        }\n\n        /*eslint-disable no-bitwise*/\n        lc = c | 0x20;\n\n        if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n          return lc - 0x61 + 10;\n        }\n\n        return -1;\n      }\n\n      function escapedHexLen(c) {\n        if (c === 0x78/* x */) { return 2; }\n        if (c === 0x75/* u */) { return 4; }\n        if (c === 0x55/* U */) { return 8; }\n        return 0;\n      }\n\n      function fromDecimalCode(c) {\n        if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n          return c - 0x30;\n        }\n\n        return -1;\n      }\n\n      function simpleEscapeSequence(c) {\n        /* eslint-disable indent */\n        return (c === 0x30/* 0 */) ? '\\x00' :\n          (c === 0x61/* a */) ? '\\x07' :\n            (c === 0x62/* b */) ? '\\x08' :\n              (c === 0x74/* t */) ? '\\x09' :\n                (c === 0x09/* Tab */) ? '\\x09' :\n                  (c === 0x6E/* n */) ? '\\x0A' :\n                    (c === 0x76/* v */) ? '\\x0B' :\n                      (c === 0x66/* f */) ? '\\x0C' :\n                        (c === 0x72/* r */) ? '\\x0D' :\n                          (c === 0x65/* e */) ? '\\x1B' :\n                            (c === 0x20/* Space */) ? ' ' :\n                              (c === 0x22/* \" */) ? '\\x22' :\n                                (c === 0x2F/* / */) ? '/' :\n                                  (c === 0x5C/* \\ */) ? '\\x5C' :\n                                    (c === 0x4E/* N */) ? '\\x85' :\n                                      (c === 0x5F/* _ */) ? '\\xA0' :\n                                        (c === 0x4C/* L */) ? '\\u2028' :\n                                          (c === 0x50/* P */) ? '\\u2029' : '';\n      }\n\n      function charFromCodepoint(c) {\n        if (c <= 0xFFFF) {\n          return String.fromCharCode(c);\n        }\n        // Encode UTF-16 surrogate pair\n        // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n        return String.fromCharCode(\n          ((c - 0x010000) >> 10) + 0xD800,\n          ((c - 0x010000) & 0x03FF) + 0xDC00\n        );\n      }\n\n      var simpleEscapeCheck = new Array(256); // integer, for fast access\n      var simpleEscapeMap = new Array(256);\n      for (var i = 0; i < 256; i++) {\n        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n        simpleEscapeMap[i] = simpleEscapeSequence(i);\n      }\n\n\n      function State(input, options) {\n        this.input = input;\n\n        this.filename = options['filename'] || null;\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.onWarning = options['onWarning'] || null;\n        this.legacy = options['legacy'] || false;\n        this.json = options['json'] || false;\n        this.listener = options['listener'] || null;\n\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.typeMap = this.schema.compiledTypeMap;\n\n        this.length = input.length;\n        this.position = 0;\n        this.line = 0;\n        this.lineStart = 0;\n        this.lineIndent = 0;\n\n        this.documents = [];\n\n        /*\n        this.version;\n        this.checkLineBreaks;\n        this.tagMap;\n        this.anchorMap;\n        this.tag;\n        this.anchor;\n        this.kind;\n        this.result;*/\n\n      }\n\n\n      function generateError(state, message) {\n        return new YAMLException(\n          message,\n          new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n      }\n\n      function throwError(state, message) {\n        throw generateError(state, message);\n      }\n\n      function throwWarning(state, message) {\n        if (state.onWarning) {\n          state.onWarning.call(null, generateError(state, message));\n        }\n      }\n\n\n      var directiveHandlers = {\n\n        YAML: function handleYamlDirective(state, name, args) {\n\n          var match, major, minor;\n\n          if (state.version !== null) {\n            throwError(state, 'duplication of %YAML directive');\n          }\n\n          if (args.length !== 1) {\n            throwError(state, 'YAML directive accepts exactly one argument');\n          }\n\n          match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n          if (match === null) {\n            throwError(state, 'ill-formed argument of the YAML directive');\n          }\n\n          major = parseInt(match[1], 10);\n          minor = parseInt(match[2], 10);\n\n          if (major !== 1) {\n            throwError(state, 'unacceptable YAML version of the document');\n          }\n\n          state.version = args[0];\n          state.checkLineBreaks = (minor < 2);\n\n          if (minor !== 1 && minor !== 2) {\n            throwWarning(state, 'unsupported YAML version of the document');\n          }\n        },\n\n        TAG: function handleTagDirective(state, name, args) {\n\n          var handle, prefix;\n\n          if (args.length !== 2) {\n            throwError(state, 'TAG directive accepts exactly two arguments');\n          }\n\n          handle = args[0];\n          prefix = args[1];\n\n          if (!PATTERN_TAG_HANDLE.test(handle)) {\n            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n          }\n\n          if (_hasOwnProperty.call(state.tagMap, handle)) {\n            throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n          }\n\n          if (!PATTERN_TAG_URI.test(prefix)) {\n            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n          }\n\n          state.tagMap[handle] = prefix;\n        }\n      };\n\n\n      function captureSegment(state, start, end, checkJson) {\n        var _position, _length, _character, _result;\n\n        if (start < end) {\n          _result = state.input.slice(start, end);\n\n          if (checkJson) {\n            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n              _character = _result.charCodeAt(_position);\n              if (!(_character === 0x09 ||\n                (0x20 <= _character && _character <= 0x10FFFF))) {\n                throwError(state, 'expected valid JSON character');\n              }\n            }\n          } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n            throwError(state, 'the stream contains non-printable characters');\n          }\n\n          state.result += _result;\n        }\n      }\n\n      function mergeMappings(state, destination, source, overridableKeys) {\n        var sourceKeys, key, index, quantity;\n\n        if (!common.isObject(source)) {\n          throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n        }\n\n        sourceKeys = Object.keys(source);\n\n        for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n          key = sourceKeys[index];\n\n          if (!_hasOwnProperty.call(destination, key)) {\n            destination[key] = source[key];\n            overridableKeys[key] = true;\n          }\n        }\n      }\n\n      function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n        var index, quantity;\n\n        // The output is a plain object here, so keys can only be strings.\n        // We need to convert keyNode to a string, but doing so can hang the process\n        // (deeply nested arrays that explode exponentially using aliases).\n        if (Array.isArray(keyNode)) {\n          keyNode = Array.prototype.slice.call(keyNode);\n\n          for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n            if (Array.isArray(keyNode[index])) {\n              throwError(state, 'nested arrays are not supported inside keys');\n            }\n\n            if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n              keyNode[index] = '[object Object]';\n            }\n          }\n        }\n\n        // Avoid code execution in load() via toString property\n        // (still use its own toString for arrays, timestamps,\n        // and whatever user schema extensions happen to have @@toStringTag)\n        if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n          keyNode = '[object Object]';\n        }\n\n\n        keyNode = String(keyNode);\n\n        if (_result === null) {\n          _result = {};\n        }\n\n        if (keyTag === 'tag:yaml.org,2002:merge') {\n          if (Array.isArray(valueNode)) {\n            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n              mergeMappings(state, _result, valueNode[index], overridableKeys);\n            }\n          } else {\n            mergeMappings(state, _result, valueNode, overridableKeys);\n          }\n        } else {\n          if (!state.json &&\n            !_hasOwnProperty.call(overridableKeys, keyNode) &&\n            _hasOwnProperty.call(_result, keyNode)) {\n            state.line = startLine || state.line;\n            state.position = startPos || state.position;\n            throwError(state, 'duplicated mapping key');\n          }\n          _result[keyNode] = valueNode;\n          delete overridableKeys[keyNode];\n        }\n\n        return _result;\n      }\n\n      function readLineBreak(state) {\n        var ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x0A/* LF */) {\n          state.position++;\n        } else if (ch === 0x0D/* CR */) {\n          state.position++;\n          if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n            state.position++;\n          }\n        } else {\n          throwError(state, 'a line break is expected');\n        }\n\n        state.line += 1;\n        state.lineStart = state.position;\n      }\n\n      function skipSeparationSpace(state, allowComments, checkIndent) {\n        var lineBreaks = 0,\n          ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (allowComments && ch === 0x23/* # */) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n          }\n\n          if (is_EOL(ch)) {\n            readLineBreak(state);\n\n            ch = state.input.charCodeAt(state.position);\n            lineBreaks++;\n            state.lineIndent = 0;\n\n            while (ch === 0x20/* Space */) {\n              state.lineIndent++;\n              ch = state.input.charCodeAt(++state.position);\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n          throwWarning(state, 'deficient indentation');\n        }\n\n        return lineBreaks;\n      }\n\n      function testDocumentSeparator(state) {\n        var _position = state.position,\n          ch;\n\n        ch = state.input.charCodeAt(_position);\n\n        // Condition state.position === state.lineStart is tested\n        // in parent on each call, for efficiency. No needs to test here again.\n        if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n          ch === state.input.charCodeAt(_position + 1) &&\n          ch === state.input.charCodeAt(_position + 2)) {\n\n          _position += 3;\n\n          ch = state.input.charCodeAt(_position);\n\n          if (ch === 0 || is_WS_OR_EOL(ch)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function writeFoldedLines(state, count) {\n        if (count === 1) {\n          state.result += ' ';\n        } else if (count > 1) {\n          state.result += common.repeat('\\n', count - 1);\n        }\n      }\n\n\n      function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n        var preceding,\n          following,\n          captureStart,\n          captureEnd,\n          hasPendingContent,\n          _line,\n          _lineStart,\n          _lineIndent,\n          _kind = state.kind,\n          _result = state.result,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (is_WS_OR_EOL(ch) ||\n          is_FLOW_INDICATOR(ch) ||\n          ch === 0x23/* # */ ||\n          ch === 0x26/* & */ ||\n          ch === 0x2A/* * */ ||\n          ch === 0x21/* ! */ ||\n          ch === 0x7C/* | */ ||\n          ch === 0x3E/* > */ ||\n          ch === 0x27/* ' */ ||\n          ch === 0x22/* \" */ ||\n          ch === 0x25/* % */ ||\n          ch === 0x40/* @ */ ||\n          ch === 0x60/* ` */) {\n          return false;\n        }\n\n        if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n          following = state.input.charCodeAt(state.position + 1);\n\n          if (is_WS_OR_EOL(following) ||\n            withinFlowCollection && is_FLOW_INDICATOR(following)) {\n            return false;\n          }\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        captureStart = captureEnd = state.position;\n        hasPendingContent = false;\n\n        while (ch !== 0) {\n          if (ch === 0x3A/* : */) {\n            following = state.input.charCodeAt(state.position + 1);\n\n            if (is_WS_OR_EOL(following) ||\n              withinFlowCollection && is_FLOW_INDICATOR(following)) {\n              break;\n            }\n\n          } else if (ch === 0x23/* # */) {\n            preceding = state.input.charCodeAt(state.position - 1);\n\n            if (is_WS_OR_EOL(preceding)) {\n              break;\n            }\n\n          } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n            withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n            break;\n\n          } else if (is_EOL(ch)) {\n            _line = state.line;\n            _lineStart = state.lineStart;\n            _lineIndent = state.lineIndent;\n            skipSeparationSpace(state, false, -1);\n\n            if (state.lineIndent >= nodeIndent) {\n              hasPendingContent = true;\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            } else {\n              state.position = captureEnd;\n              state.line = _line;\n              state.lineStart = _lineStart;\n              state.lineIndent = _lineIndent;\n              break;\n            }\n          }\n\n          if (hasPendingContent) {\n            captureSegment(state, captureStart, captureEnd, false);\n            writeFoldedLines(state, state.line - _line);\n            captureStart = captureEnd = state.position;\n            hasPendingContent = false;\n          }\n\n          if (!is_WHITE_SPACE(ch)) {\n            captureEnd = state.position + 1;\n          }\n\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        captureSegment(state, captureStart, captureEnd, false);\n\n        if (state.result) {\n          return true;\n        }\n\n        state.kind = _kind;\n        state.result = _result;\n        return false;\n      }\n\n      function readSingleQuotedScalar(state, nodeIndent) {\n        var ch,\n          captureStart, captureEnd;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x27/* ' */) {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x27/* ' */) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n\n            if (ch === 0x27/* ' */) {\n              captureStart = state.position;\n              state.position++;\n              captureEnd = state.position;\n            } else {\n              return true;\n            }\n\n          } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a single quoted scalar');\n      }\n\n      function readDoubleQuotedScalar(state, nodeIndent) {\n        var captureStart,\n          captureEnd,\n          hexLength,\n          hexResult,\n          tmp,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x22/* \" */) {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x22/* \" */) {\n            captureSegment(state, captureStart, state.position, true);\n            state.position++;\n            return true;\n\n          } else if (ch === 0x5C/* \\ */) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n\n            if (is_EOL(ch)) {\n              skipSeparationSpace(state, false, nodeIndent);\n\n              // TODO: rework to inline fn with no type cast?\n            } else if (ch < 256 && simpleEscapeCheck[ch]) {\n              state.result += simpleEscapeMap[ch];\n              state.position++;\n\n            } else if ((tmp = escapedHexLen(ch)) > 0) {\n              hexLength = tmp;\n              hexResult = 0;\n\n              for (; hexLength > 0; hexLength--) {\n                ch = state.input.charCodeAt(++state.position);\n\n                if ((tmp = fromHexCode(ch)) >= 0) {\n                  hexResult = (hexResult << 4) + tmp;\n\n                } else {\n                  throwError(state, 'expected hexadecimal character');\n                }\n              }\n\n              state.result += charFromCodepoint(hexResult);\n\n              state.position++;\n\n            } else {\n              throwError(state, 'unknown escape sequence');\n            }\n\n            captureStart = captureEnd = state.position;\n\n          } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a double quoted scalar');\n      }\n\n      function readFlowCollection(state, nodeIndent) {\n        var readNext = true,\n          _line,\n          _tag = state.tag,\n          _result,\n          _anchor = state.anchor,\n          following,\n          terminator,\n          isPair,\n          isExplicitPair,\n          isMapping,\n          overridableKeys = {},\n          keyNode,\n          keyTag,\n          valueNode,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x5B/* [ */) {\n          terminator = 0x5D;/* ] */\n          isMapping = false;\n          _result = [];\n        } else if (ch === 0x7B/* { */) {\n          terminator = 0x7D;/* } */\n          isMapping = true;\n          _result = {};\n        } else {\n          return false;\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        while (ch !== 0) {\n          skipSeparationSpace(state, true, nodeIndent);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === terminator) {\n            state.position++;\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = isMapping ? 'mapping' : 'sequence';\n            state.result = _result;\n            return true;\n          } else if (!readNext) {\n            throwError(state, 'missed comma between flow collection entries');\n          }\n\n          keyTag = keyNode = valueNode = null;\n          isPair = isExplicitPair = false;\n\n          if (ch === 0x3F/* ? */) {\n            following = state.input.charCodeAt(state.position + 1);\n\n            if (is_WS_OR_EOL(following)) {\n              isPair = isExplicitPair = true;\n              state.position++;\n              skipSeparationSpace(state, true, nodeIndent);\n            }\n          }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n          keyTag = state.tag;\n          keyNode = state.result;\n          skipSeparationSpace(state, true, nodeIndent);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n            isPair = true;\n            state.input.charCodeAt(++state.position);\n            skipSeparationSpace(state, true, nodeIndent);\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n            valueNode = state.result;\n          }\n\n          if (isMapping) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n          } else if (isPair) {\n            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n          } else {\n            _result.push(keyNode);\n          }\n\n          skipSeparationSpace(state, true, nodeIndent);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === 0x2C/* , */) {\n            readNext = true;\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            readNext = false;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a flow collection');\n      }\n\n      function readBlockScalar(state, nodeIndent) {\n        var captureStart,\n          folding,\n          chomping = CHOMPING_CLIP,\n          didReadContent = false,\n          detectedIndent = false,\n          textIndent = nodeIndent,\n          emptyLines = 0,\n          atMoreIndented = false,\n          tmp,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x7C/* | */) {\n          folding = false;\n        } else if (ch === 0x3E/* > */) {\n          folding = true;\n        } else {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n\n        while (ch !== 0) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n            if (CHOMPING_CLIP === chomping) {\n              chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n            } else {\n              throwError(state, 'repeat of a chomping mode identifier');\n            }\n\n          } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n            if (tmp === 0) {\n              throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n            } else if (!detectedIndent) {\n              textIndent = nodeIndent + tmp - 1;\n              detectedIndent = true;\n            } else {\n              throwError(state, 'repeat of an indentation width identifier');\n            }\n\n          } else {\n            break;\n          }\n        }\n\n        if (is_WHITE_SPACE(ch)) {\n          do { ch = state.input.charCodeAt(++state.position); }\n          while (is_WHITE_SPACE(ch));\n\n          if (ch === 0x23/* # */) {\n            do { ch = state.input.charCodeAt(++state.position); }\n            while (!is_EOL(ch) && (ch !== 0));\n          }\n        }\n\n        while (ch !== 0) {\n          readLineBreak(state);\n          state.lineIndent = 0;\n\n          ch = state.input.charCodeAt(state.position);\n\n          while ((!detectedIndent || state.lineIndent < textIndent) &&\n            (ch === 0x20/* Space */)) {\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (!detectedIndent && state.lineIndent > textIndent) {\n            textIndent = state.lineIndent;\n          }\n\n          if (is_EOL(ch)) {\n            emptyLines++;\n            continue;\n          }\n\n          // End of the scalar.\n          if (state.lineIndent < textIndent) {\n\n            // Perform the chomping.\n            if (chomping === CHOMPING_KEEP) {\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n            } else if (chomping === CHOMPING_CLIP) {\n              if (didReadContent) { // i.e. only if the scalar is not empty.\n                state.result += '\\n';\n              }\n            }\n\n            // Break this `while` cycle and go to the funciton's epilogue.\n            break;\n          }\n\n          // Folded style: use fancy rules to handle line breaks.\n          if (folding) {\n\n            // Lines starting with white space characters (more-indented lines) are not folded.\n            if (is_WHITE_SPACE(ch)) {\n              atMoreIndented = true;\n              // except for the first content line (cf. Example 8.1)\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n              // End of more-indented block.\n            } else if (atMoreIndented) {\n              atMoreIndented = false;\n              state.result += common.repeat('\\n', emptyLines + 1);\n\n              // Just one line break - perceive as the same line.\n            } else if (emptyLines === 0) {\n              if (didReadContent) { // i.e. only if we have already read some scalar content.\n                state.result += ' ';\n              }\n\n              // Several line breaks - perceive as different lines.\n            } else {\n              state.result += common.repeat('\\n', emptyLines);\n            }\n\n            // Literal style: just add exact number of line breaks between content lines.\n          } else {\n            // Keep all line breaks except the header line break.\n            state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n          }\n\n          didReadContent = true;\n          detectedIndent = true;\n          emptyLines = 0;\n          captureStart = state.position;\n\n          while (!is_EOL(ch) && (ch !== 0)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          captureSegment(state, captureStart, state.position, false);\n        }\n\n        return true;\n      }\n\n      function readBlockSequence(state, nodeIndent) {\n        var _line,\n          _tag = state.tag,\n          _anchor = state.anchor,\n          _result = [],\n          following,\n          detected = false,\n          ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n\n          if (ch !== 0x2D/* - */) {\n            break;\n          }\n\n          following = state.input.charCodeAt(state.position + 1);\n\n          if (!is_WS_OR_EOL(following)) {\n            break;\n          }\n\n          detected = true;\n          state.position++;\n\n          if (skipSeparationSpace(state, true, -1)) {\n            if (state.lineIndent <= nodeIndent) {\n              _result.push(null);\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            }\n          }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n          _result.push(state.result);\n          skipSeparationSpace(state, true, -1);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n            throwError(state, 'bad indentation of a sequence entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        }\n\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'sequence';\n          state.result = _result;\n          return true;\n        }\n        return false;\n      }\n\n      function readBlockMapping(state, nodeIndent, flowIndent) {\n        var following,\n          allowCompact,\n          _line,\n          _pos,\n          _tag = state.tag,\n          _anchor = state.anchor,\n          _result = {},\n          overridableKeys = {},\n          keyTag = null,\n          keyNode = null,\n          valueNode = null,\n          atExplicitKey = false,\n          detected = false,\n          ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          following = state.input.charCodeAt(state.position + 1);\n          _line = state.line; // Save the current line.\n          _pos = state.position;\n\n          //\n          // Explicit notation case. There are two separate blocks:\n          // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n          //\n          if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n            if (ch === 0x3F/* ? */) {\n              if (atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                keyTag = keyNode = valueNode = null;\n              }\n\n              detected = true;\n              atExplicitKey = true;\n              allowCompact = true;\n\n            } else if (atExplicitKey) {\n              // i.e. 0x3A/* : */ === character after the explicit key.\n              atExplicitKey = false;\n              allowCompact = true;\n\n            } else {\n              throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n            }\n\n            state.position += 1;\n            ch = following;\n\n            //\n            // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n            //\n          } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n            if (state.line === _line) {\n              ch = state.input.charCodeAt(state.position);\n\n              while (is_WHITE_SPACE(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n\n              if (ch === 0x3A/* : */) {\n                ch = state.input.charCodeAt(++state.position);\n\n                if (!is_WS_OR_EOL(ch)) {\n                  throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n                }\n\n                if (atExplicitKey) {\n                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                  keyTag = keyNode = valueNode = null;\n                }\n\n                detected = true;\n                atExplicitKey = false;\n                allowCompact = false;\n                keyTag = state.tag;\n                keyNode = state.result;\n\n              } else if (detected) {\n                throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n              } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n              }\n\n            } else if (detected) {\n              throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n            } else {\n              state.tag = _tag;\n              state.anchor = _anchor;\n              return true; // Keep the result of `composeNode`.\n            }\n\n          } else {\n            break; // Reading is done. Go to the epilogue.\n          }\n\n          //\n          // Common reading code for both explicit and implicit notations.\n          //\n          if (state.line === _line || state.lineIndent > nodeIndent) {\n            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n              if (atExplicitKey) {\n                keyNode = state.result;\n              } else {\n                valueNode = state.result;\n              }\n            }\n\n            if (!atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n          }\n\n          if (state.lineIndent > nodeIndent && (ch !== 0)) {\n            throwError(state, 'bad indentation of a mapping entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        }\n\n        //\n        // Epilogue.\n        //\n\n        // Special case: last mapping's node contains only the key in explicit notation.\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n        }\n\n        // Expose the resulting mapping.\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'mapping';\n          state.result = _result;\n        }\n\n        return detected;\n      }\n\n      function readTagProperty(state) {\n        var _position,\n          isVerbatim = false,\n          isNamed = false,\n          tagHandle,\n          tagName,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x21/* ! */) return false;\n\n        if (state.tag !== null) {\n          throwError(state, 'duplication of a tag property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x3C/* < */) {\n          isVerbatim = true;\n          ch = state.input.charCodeAt(++state.position);\n\n        } else if (ch === 0x21/* ! */) {\n          isNamed = true;\n          tagHandle = '!!';\n          ch = state.input.charCodeAt(++state.position);\n\n        } else {\n          tagHandle = '!';\n        }\n\n        _position = state.position;\n\n        if (isVerbatim) {\n          do { ch = state.input.charCodeAt(++state.position); }\n          while (ch !== 0 && ch !== 0x3E/* > */);\n\n          if (state.position < state.length) {\n            tagName = state.input.slice(_position, state.position);\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            throwError(state, 'unexpected end of the stream within a verbatim tag');\n          }\n        } else {\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n            if (ch === 0x21/* ! */) {\n              if (!isNamed) {\n                tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                  throwError(state, 'named tag handle cannot contain such characters');\n                }\n\n                isNamed = true;\n                _position = state.position + 1;\n              } else {\n                throwError(state, 'tag suffix cannot contain exclamation marks');\n              }\n            }\n\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          tagName = state.input.slice(_position, state.position);\n\n          if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n            throwError(state, 'tag suffix cannot contain flow indicator characters');\n          }\n        }\n\n        if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n          throwError(state, 'tag name cannot contain such characters: ' + tagName);\n        }\n\n        if (isVerbatim) {\n          state.tag = tagName;\n\n        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n          state.tag = state.tagMap[tagHandle] + tagName;\n\n        } else if (tagHandle === '!') {\n          state.tag = '!' + tagName;\n\n        } else if (tagHandle === '!!') {\n          state.tag = 'tag:yaml.org,2002:' + tagName;\n\n        } else {\n          throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n        }\n\n        return true;\n      }\n\n      function readAnchorProperty(state) {\n        var _position,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x26/* & */) return false;\n\n        if (state.anchor !== null) {\n          throwError(state, 'duplication of an anchor property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an anchor node must contain at least one character');\n        }\n\n        state.anchor = state.input.slice(_position, state.position);\n        return true;\n      }\n\n      function readAlias(state) {\n        var _position, alias,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x2A/* * */) return false;\n\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an alias node must contain at least one character');\n        }\n\n        alias = state.input.slice(_position, state.position);\n\n        if (!state.anchorMap.hasOwnProperty(alias)) {\n          throwError(state, 'unidentified alias \"' + alias + '\"');\n        }\n\n        state.result = state.anchorMap[alias];\n        skipSeparationSpace(state, true, -1);\n        return true;\n      }\n\n      function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n        var allowBlockStyles,\n          allowBlockScalars,\n          allowBlockCollections,\n          indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n          atNewLine = false,\n          hasContent = false,\n          typeIndex,\n          typeQuantity,\n          type,\n          flowIndent,\n          blockIndent;\n\n        if (state.listener !== null) {\n          state.listener('open', state);\n        }\n\n        state.tag = null;\n        state.anchor = null;\n        state.kind = null;\n        state.result = null;\n\n        allowBlockStyles = allowBlockScalars = allowBlockCollections =\n          CONTEXT_BLOCK_OUT === nodeContext ||\n          CONTEXT_BLOCK_IN === nodeContext;\n\n        if (allowToSeek) {\n          if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n\n            if (state.lineIndent > parentIndent) {\n              indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n              indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n              indentStatus = -1;\n            }\n          }\n        }\n\n        if (indentStatus === 1) {\n          while (readTagProperty(state) || readAnchorProperty(state)) {\n            if (skipSeparationSpace(state, true, -1)) {\n              atNewLine = true;\n              allowBlockCollections = allowBlockStyles;\n\n              if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n              } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n              } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n              }\n            } else {\n              allowBlockCollections = false;\n            }\n          }\n        }\n\n        if (allowBlockCollections) {\n          allowBlockCollections = atNewLine || allowCompact;\n        }\n\n        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n          if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n            flowIndent = parentIndent;\n          } else {\n            flowIndent = parentIndent + 1;\n          }\n\n          blockIndent = state.position - state.lineStart;\n\n          if (indentStatus === 1) {\n            if (allowBlockCollections &&\n              (readBlockSequence(state, blockIndent) ||\n                readBlockMapping(state, blockIndent, flowIndent)) ||\n              readFlowCollection(state, flowIndent)) {\n              hasContent = true;\n            } else {\n              if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n                readSingleQuotedScalar(state, flowIndent) ||\n                readDoubleQuotedScalar(state, flowIndent)) {\n                hasContent = true;\n\n              } else if (readAlias(state)) {\n                hasContent = true;\n\n                if (state.tag !== null || state.anchor !== null) {\n                  throwError(state, 'alias node should not have any properties');\n                }\n\n              } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                hasContent = true;\n\n                if (state.tag === null) {\n                  state.tag = '?';\n                }\n              }\n\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else if (indentStatus === 0) {\n            // Special case: block sequences are allowed to have same indentation level as the parent.\n            // http://www.yaml.org/spec/1.2/spec.html#id2799784\n            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n          }\n        }\n\n        if (state.tag !== null && state.tag !== '!') {\n          if (state.tag === '?') {\n            // Implicit resolving is not allowed for non-scalar types, and '?'\n            // non-specific tag is only automatically assigned to plain scalars.\n            //\n            // We only need to check kind conformity in case user explicitly assigns '?'\n            // tag, for example like this: \"!<?> [0]\"\n            //\n            if (state.result !== null && state.kind !== 'scalar') {\n              throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n            }\n\n            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n              type = state.implicitTypes[typeIndex];\n\n              if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n                state.result = type.construct(state.result);\n                state.tag = type.tag;\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n                break;\n              }\n            }\n          } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n            type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n            if (state.result !== null && type.kind !== state.kind) {\n              throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n            }\n\n            if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n              throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n            } else {\n              state.result = type.construct(state.result);\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else {\n            throwError(state, 'unknown tag !<' + state.tag + '>');\n          }\n        }\n\n        if (state.listener !== null) {\n          state.listener('close', state);\n        }\n        return state.tag !== null || state.anchor !== null || hasContent;\n      }\n\n      function readDocument(state) {\n        var documentStart = state.position,\n          _position,\n          directiveName,\n          directiveArgs,\n          hasDirectives = false,\n          ch;\n\n        state.version = null;\n        state.checkLineBreaks = state.legacy;\n        state.tagMap = {};\n        state.anchorMap = {};\n\n        while ((state.input.charCodeAt(state.position)) !== 0) {\n          skipSeparationSpace(state, true, -1);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n            break;\n          }\n\n          hasDirectives = true;\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          directiveName = state.input.slice(_position, state.position);\n          directiveArgs = [];\n\n          if (directiveName.length < 1) {\n            throwError(state, 'directive name must not be less than one character in length');\n          }\n\n          while (ch !== 0) {\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            if (ch === 0x23/* # */) {\n              do { ch = state.input.charCodeAt(++state.position); }\n              while (ch !== 0 && !is_EOL(ch));\n              break;\n            }\n\n            if (is_EOL(ch)) break;\n\n            _position = state.position;\n\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            directiveArgs.push(state.input.slice(_position, state.position));\n          }\n\n          if (ch !== 0) readLineBreak(state);\n\n          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n            directiveHandlers[directiveName](state, directiveName, directiveArgs);\n          } else {\n            throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n          }\n        }\n\n        skipSeparationSpace(state, true, -1);\n\n        if (state.lineIndent === 0 &&\n          state.input.charCodeAt(state.position) === 0x2D/* - */ &&\n          state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n          state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n          state.position += 3;\n          skipSeparationSpace(state, true, -1);\n\n        } else if (hasDirectives) {\n          throwError(state, 'directives end mark is expected');\n        }\n\n        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n        skipSeparationSpace(state, true, -1);\n\n        if (state.checkLineBreaks &&\n          PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n          throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n        }\n\n        state.documents.push(state.result);\n\n        if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n          if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n          }\n          return;\n        }\n\n        if (state.position < (state.length - 1)) {\n          throwError(state, 'end of the stream or a document separator is expected');\n        } else {\n          return;\n        }\n      }\n\n\n      function loadDocuments(input, options) {\n        input = String(input);\n        options = options || {};\n\n        if (input.length !== 0) {\n\n          // Add tailing `\\n` if not exists\n          if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n            input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n            input += '\\n';\n          }\n\n          // Strip BOM\n          if (input.charCodeAt(0) === 0xFEFF) {\n            input = input.slice(1);\n          }\n        }\n\n        var state = new State(input, options);\n\n        var nullpos = input.indexOf('\\0');\n\n        if (nullpos !== -1) {\n          state.position = nullpos;\n          throwError(state, 'null byte is not allowed in input');\n        }\n\n        // Use 0 as string terminator. That significantly simplifies bounds check.\n        state.input += '\\0';\n\n        while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n          state.lineIndent += 1;\n          state.position += 1;\n        }\n\n        while (state.position < (state.length - 1)) {\n          readDocument(state);\n        }\n\n        return state.documents;\n      }\n\n\n      function loadAll(input, iterator, options) {\n        if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        var documents = loadDocuments(input, options);\n\n        if (typeof iterator !== 'function') {\n          return documents;\n        }\n\n        for (var index = 0, length = documents.length; index < length; index += 1) {\n          iterator(documents[index]);\n        }\n      }\n\n\n      function load(input, options) {\n        var documents = loadDocuments(input, options);\n\n        if (documents.length === 0) {\n          /*eslint-disable no-undefined*/\n          return undefined;\n        } else if (documents.length === 1) {\n          return documents[0];\n        }\n        throw new YAMLException('expected a single document in the stream, but found more');\n      }\n\n\n      function safeLoadAll(input, iterator, options) {\n        if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n      }\n\n\n      function safeLoad(input, options) {\n        return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n      }\n\n\n      module.exports.loadAll = loadAll;\n      module.exports.load = load;\n      module.exports.safeLoadAll = safeLoadAll;\n      module.exports.safeLoad = safeLoad;\n\n    }, { \"./common\": 2, \"./exception\": 4, \"./mark\": 6, \"./schema/default_full\": 9, \"./schema/default_safe\": 10 }], 6: [function (require, module, exports) {\n      'use strict';\n\n\n      var common = require('./common');\n\n\n      function Mark(name, buffer, position, line, column) {\n        this.name = name;\n        this.buffer = buffer;\n        this.position = position;\n        this.line = line;\n        this.column = column;\n      }\n\n\n      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n        var head, start, tail, end, snippet;\n\n        if (!this.buffer) return null;\n\n        indent = indent || 4;\n        maxLength = maxLength || 75;\n\n        head = '';\n        start = this.position;\n\n        while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n          start -= 1;\n          if (this.position - start > (maxLength / 2 - 1)) {\n            head = ' ... ';\n            start += 5;\n            break;\n          }\n        }\n\n        tail = '';\n        end = this.position;\n\n        while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n          end += 1;\n          if (end - this.position > (maxLength / 2 - 1)) {\n            tail = ' ... ';\n            end -= 5;\n            break;\n          }\n        }\n\n        snippet = this.buffer.slice(start, end);\n\n        return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n          common.repeat(' ', indent + this.position - start + head.length) + '^';\n      };\n\n\n      Mark.prototype.toString = function toString(compact) {\n        var snippet, where = '';\n\n        if (this.name) {\n          where += 'in \"' + this.name + '\" ';\n        }\n\n        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n        if (!compact) {\n          snippet = this.getSnippet();\n\n          if (snippet) {\n            where += ':\\n' + snippet;\n          }\n        }\n\n        return where;\n      };\n\n\n      module.exports = Mark;\n\n    }, { \"./common\": 2 }], 7: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable max-len*/\n\n      var common = require('./common');\n      var YAMLException = require('./exception');\n      var Type = require('./type');\n\n\n      function compileList(schema, name, result) {\n        var exclude = [];\n\n        schema.include.forEach(function (includedSchema) {\n          result = compileList(includedSchema, name, result);\n        });\n\n        schema[name].forEach(function (currentType) {\n          result.forEach(function (previousType, previousIndex) {\n            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n              exclude.push(previousIndex);\n            }\n          });\n\n          result.push(currentType);\n        });\n\n        return result.filter(function (type, index) {\n          return exclude.indexOf(index) === -1;\n        });\n      }\n\n\n      function compileMap(/* lists... */) {\n        var result = {\n          scalar: {},\n          sequence: {},\n          mapping: {},\n          fallback: {}\n        }, index, length;\n\n        function collectType(type) {\n          result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n        }\n\n        for (index = 0, length = arguments.length; index < length; index += 1) {\n          arguments[index].forEach(collectType);\n        }\n        return result;\n      }\n\n\n      function Schema(definition) {\n        this.include = definition.include || [];\n        this.implicit = definition.implicit || [];\n        this.explicit = definition.explicit || [];\n\n        this.implicit.forEach(function (type) {\n          if (type.loadKind && type.loadKind !== 'scalar') {\n            throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n          }\n        });\n\n        this.compiledImplicit = compileList(this, 'implicit', []);\n        this.compiledExplicit = compileList(this, 'explicit', []);\n        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n      }\n\n\n      Schema.DEFAULT = null;\n\n\n      Schema.create = function createSchema() {\n        var schemas, types;\n\n        switch (arguments.length) {\n          case 1:\n            schemas = Schema.DEFAULT;\n            types = arguments[0];\n            break;\n\n          case 2:\n            schemas = arguments[0];\n            types = arguments[1];\n            break;\n\n          default:\n            throw new YAMLException('Wrong number of arguments for Schema.create function');\n        }\n\n        schemas = common.toArray(schemas);\n        types = common.toArray(types);\n\n        if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n          throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n        }\n\n        if (!types.every(function (type) { return type instanceof Type; })) {\n          throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n        }\n\n        return new Schema({\n          include: schemas,\n          explicit: types\n        });\n      };\n\n\n      module.exports = Schema;\n\n    }, { \"./common\": 2, \"./exception\": 4, \"./type\": 13 }], 8: [function (require, module, exports) {\n      // Standard YAML's Core schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2804923\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        include: [\n          require('./json')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"./json\": 12 }], 9: [function (require, module, exports) {\n      // JS-YAML's default schema for `load` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on JS-YAML's default safe schema and includes\n      // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n      //\n      // Also this schema is used as default base schema at `Schema.create` function.\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = Schema.DEFAULT = new Schema({\n        include: [\n          require('./default_safe')\n        ],\n        explicit: [\n          require('../type/js/undefined'),\n          require('../type/js/regexp'),\n          require('../type/js/function')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/js/function\": 18, \"../type/js/regexp\": 19, \"../type/js/undefined\": 20, \"./default_safe\": 10 }], 10: [function (require, module, exports) {\n      // JS-YAML's default schema for `safeLoad` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on standard YAML's Core schema and includes most of\n      // extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        include: [\n          require('./core')\n        ],\n        implicit: [\n          require('../type/timestamp'),\n          require('../type/merge')\n        ],\n        explicit: [\n          require('../type/binary'),\n          require('../type/omap'),\n          require('../type/pairs'),\n          require('../type/set')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/binary\": 14, \"../type/merge\": 22, \"../type/omap\": 24, \"../type/pairs\": 25, \"../type/set\": 27, \"../type/timestamp\": 29, \"./core\": 8 }], 11: [function (require, module, exports) {\n      // Standard YAML's Failsafe schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        explicit: [\n          require('../type/str'),\n          require('../type/seq'),\n          require('../type/map')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/map\": 21, \"../type/seq\": 26, \"../type/str\": 28 }], 12: [function (require, module, exports) {\n      // Standard YAML's JSON schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2803231\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, this schema is not such strict as defined in the YAML specification.\n      // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        include: [\n          require('./failsafe')\n        ],\n        implicit: [\n          require('../type/null'),\n          require('../type/bool'),\n          require('../type/int'),\n          require('../type/float')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/bool\": 15, \"../type/float\": 16, \"../type/int\": 17, \"../type/null\": 23, \"./failsafe\": 11 }], 13: [function (require, module, exports) {\n      'use strict';\n\n      var YAMLException = require('./exception');\n\n      var TYPE_CONSTRUCTOR_OPTIONS = [\n        'kind',\n        'resolve',\n        'construct',\n        'instanceOf',\n        'predicate',\n        'represent',\n        'defaultStyle',\n        'styleAliases'\n      ];\n\n      var YAML_NODE_KINDS = [\n        'scalar',\n        'sequence',\n        'mapping'\n      ];\n\n      function compileStyleAliases(map) {\n        var result = {};\n\n        if (map !== null) {\n          Object.keys(map).forEach(function (style) {\n            map[style].forEach(function (alias) {\n              result[String(alias)] = style;\n            });\n          });\n        }\n\n        return result;\n      }\n\n      function Type(tag, options) {\n        options = options || {};\n\n        Object.keys(options).forEach(function (name) {\n          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n            throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n          }\n        });\n\n        // TODO: Add tag format check.\n        this.tag = tag;\n        this.kind = options['kind'] || null;\n        this.resolve = options['resolve'] || function () { return true; };\n        this.construct = options['construct'] || function (data) { return data; };\n        this.instanceOf = options['instanceOf'] || null;\n        this.predicate = options['predicate'] || null;\n        this.represent = options['represent'] || null;\n        this.defaultStyle = options['defaultStyle'] || null;\n        this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n          throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n        }\n      }\n\n      module.exports = Type;\n\n    }, { \"./exception\": 4 }], 14: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable no-bitwise*/\n\n      var NodeBuffer;\n\n      try {\n        // A trick for browserified version, to not include `Buffer` shim\n        var _require = require;\n        NodeBuffer = _require('buffer').Buffer;\n      } catch (__) { }\n\n      var Type = require('../type');\n\n\n      // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n      var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\n      function resolveYamlBinary(data) {\n        if (data === null) return false;\n\n        var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n        // Convert one by one.\n        for (idx = 0; idx < max; idx++) {\n          code = map.indexOf(data.charAt(idx));\n\n          // Skip CR/LF\n          if (code > 64) continue;\n\n          // Fail on illegal characters\n          if (code < 0) return false;\n\n          bitlen += 6;\n        }\n\n        // If there are any bits left, source was corrupted\n        return (bitlen % 8) === 0;\n      }\n\n      function constructYamlBinary(data) {\n        var idx, tailbits,\n          input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n          max = input.length,\n          map = BASE64_MAP,\n          bits = 0,\n          result = [];\n\n        // Collect by 6*4 bits (3 bytes)\n\n        for (idx = 0; idx < max; idx++) {\n          if ((idx % 4 === 0) && idx) {\n            result.push((bits >> 16) & 0xFF);\n            result.push((bits >> 8) & 0xFF);\n            result.push(bits & 0xFF);\n          }\n\n          bits = (bits << 6) | map.indexOf(input.charAt(idx));\n        }\n\n        // Dump tail\n\n        tailbits = (max % 4) * 6;\n\n        if (tailbits === 0) {\n          result.push((bits >> 16) & 0xFF);\n          result.push((bits >> 8) & 0xFF);\n          result.push(bits & 0xFF);\n        } else if (tailbits === 18) {\n          result.push((bits >> 10) & 0xFF);\n          result.push((bits >> 2) & 0xFF);\n        } else if (tailbits === 12) {\n          result.push((bits >> 4) & 0xFF);\n        }\n\n        // Wrap into Buffer for NodeJS and leave Array for browser\n        if (NodeBuffer) {\n          // Support node 6.+ Buffer API when available\n          return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n        }\n\n        return result;\n      }\n\n      function representYamlBinary(object /*, style*/) {\n        var result = '', bits = 0, idx, tail,\n          max = object.length,\n          map = BASE64_MAP;\n\n        // Convert every three bytes to 4 ASCII characters.\n\n        for (idx = 0; idx < max; idx++) {\n          if ((idx % 3 === 0) && idx) {\n            result += map[(bits >> 18) & 0x3F];\n            result += map[(bits >> 12) & 0x3F];\n            result += map[(bits >> 6) & 0x3F];\n            result += map[bits & 0x3F];\n          }\n\n          bits = (bits << 8) + object[idx];\n        }\n\n        // Dump tail\n\n        tail = max % 3;\n\n        if (tail === 0) {\n          result += map[(bits >> 18) & 0x3F];\n          result += map[(bits >> 12) & 0x3F];\n          result += map[(bits >> 6) & 0x3F];\n          result += map[bits & 0x3F];\n        } else if (tail === 2) {\n          result += map[(bits >> 10) & 0x3F];\n          result += map[(bits >> 4) & 0x3F];\n          result += map[(bits << 2) & 0x3F];\n          result += map[64];\n        } else if (tail === 1) {\n          result += map[(bits >> 2) & 0x3F];\n          result += map[(bits << 4) & 0x3F];\n          result += map[64];\n          result += map[64];\n        }\n\n        return result;\n      }\n\n      function isBinary(object) {\n        return NodeBuffer && NodeBuffer.isBuffer(object);\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:binary', {\n        kind: 'scalar',\n        resolve: resolveYamlBinary,\n        construct: constructYamlBinary,\n        predicate: isBinary,\n        represent: representYamlBinary\n      });\n\n    }, { \"../type\": 13 }], 15: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlBoolean(data) {\n        if (data === null) return false;\n\n        var max = data.length;\n\n        return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n          (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n      }\n\n      function constructYamlBoolean(data) {\n        return data === 'true' ||\n          data === 'True' ||\n          data === 'TRUE';\n      }\n\n      function isBoolean(object) {\n        return Object.prototype.toString.call(object) === '[object Boolean]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:bool', {\n        kind: 'scalar',\n        resolve: resolveYamlBoolean,\n        construct: constructYamlBoolean,\n        predicate: isBoolean,\n        represent: {\n          lowercase: function (object) { return object ? 'true' : 'false'; },\n          uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n          camelcase: function (object) { return object ? 'True' : 'False'; }\n        },\n        defaultStyle: 'lowercase'\n      });\n\n    }, { \"../type\": 13 }], 16: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n      var Type = require('../type');\n\n      var YAML_FLOAT_PATTERN = new RegExp(\n        // 2.5e4, 2.5 and integers\n        '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n        // .2e4, .2\n        // special case, seems not from spec\n        '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n        // 20:59\n        '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n        // .inf\n        '|[-+]?\\\\.(?:inf|Inf|INF)' +\n        // .nan\n        '|\\\\.(?:nan|NaN|NAN))$');\n\n      function resolveYamlFloat(data) {\n        if (data === null) return false;\n\n        if (!YAML_FLOAT_PATTERN.test(data) ||\n          // Quick hack to not allow integers end with `_`\n          // Probably should update regexp & check speed\n          data[data.length - 1] === '_') {\n          return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlFloat(data) {\n        var value, sign, base, digits;\n\n        value = data.replace(/_/g, '').toLowerCase();\n        sign = value[0] === '-' ? -1 : 1;\n        digits = [];\n\n        if ('+-'.indexOf(value[0]) >= 0) {\n          value = value.slice(1);\n        }\n\n        if (value === '.inf') {\n          return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n        } else if (value === '.nan') {\n          return NaN;\n\n        } else if (value.indexOf(':') >= 0) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseFloat(v));\n          });\n\n          value = 0.0;\n          base = 1;\n\n          digits.forEach(function (d) {\n            value += d * base;\n            base *= 60;\n          });\n\n          return sign * value;\n\n        }\n        return sign * parseFloat(value);\n      }\n\n\n      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\n      function representYamlFloat(object, style) {\n        var res;\n\n        if (isNaN(object)) {\n          switch (style) {\n            case 'lowercase': return '.nan';\n            case 'uppercase': return '.NAN';\n            case 'camelcase': return '.NaN';\n          }\n        } else if (Number.POSITIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase': return '.inf';\n            case 'uppercase': return '.INF';\n            case 'camelcase': return '.Inf';\n          }\n        } else if (Number.NEGATIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase': return '-.inf';\n            case 'uppercase': return '-.INF';\n            case 'camelcase': return '-.Inf';\n          }\n        } else if (common.isNegativeZero(object)) {\n          return '-0.0';\n        }\n\n        res = object.toString(10);\n\n        // JS stringifier can build scientific format without dots: 5e-100,\n        // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n      }\n\n      function isFloat(object) {\n        return (Object.prototype.toString.call(object) === '[object Number]') &&\n          (object % 1 !== 0 || common.isNegativeZero(object));\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:float', {\n        kind: 'scalar',\n        resolve: resolveYamlFloat,\n        construct: constructYamlFloat,\n        predicate: isFloat,\n        represent: representYamlFloat,\n        defaultStyle: 'lowercase'\n      });\n\n    }, { \"../common\": 2, \"../type\": 13 }], 17: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n      var Type = require('../type');\n\n      function isHexCode(c) {\n        return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n          ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n          ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n      }\n\n      function isOctCode(c) {\n        return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n      }\n\n      function isDecCode(c) {\n        return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n      }\n\n      function resolveYamlInteger(data) {\n        if (data === null) return false;\n\n        var max = data.length,\n          index = 0,\n          hasDigits = false,\n          ch;\n\n        if (!max) return false;\n\n        ch = data[index];\n\n        // sign\n        if (ch === '-' || ch === '+') {\n          ch = data[++index];\n        }\n\n        if (ch === '0') {\n          // 0\n          if (index + 1 === max) return true;\n          ch = data[++index];\n\n          // base 2, base 8, base 16\n\n          if (ch === 'b') {\n            // base 2\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (ch !== '0' && ch !== '1') return false;\n              hasDigits = true;\n            }\n            return hasDigits && ch !== '_';\n          }\n\n\n          if (ch === 'x') {\n            // base 16\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (!isHexCode(data.charCodeAt(index))) return false;\n              hasDigits = true;\n            }\n            return hasDigits && ch !== '_';\n          }\n\n          // base 8\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === '_') continue;\n            if (!isOctCode(data.charCodeAt(index))) return false;\n            hasDigits = true;\n          }\n          return hasDigits && ch !== '_';\n        }\n\n        // base 10 (except 0) or base 60\n\n        // value should not start with `_`;\n        if (ch === '_') return false;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (ch === ':') break;\n          if (!isDecCode(data.charCodeAt(index))) {\n            return false;\n          }\n          hasDigits = true;\n        }\n\n        // Should have digits and should not end with `_`\n        if (!hasDigits || ch === '_') return false;\n\n        // if !base60 - done;\n        if (ch !== ':') return true;\n\n        // base60 almost not used, no needs to optimize\n        return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n      }\n\n      function constructYamlInteger(data) {\n        var value = data, sign = 1, ch, base, digits = [];\n\n        if (value.indexOf('_') !== -1) {\n          value = value.replace(/_/g, '');\n        }\n\n        ch = value[0];\n\n        if (ch === '-' || ch === '+') {\n          if (ch === '-') sign = -1;\n          value = value.slice(1);\n          ch = value[0];\n        }\n\n        if (value === '0') return 0;\n\n        if (ch === '0') {\n          if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n          if (value[1] === 'x') return sign * parseInt(value, 16);\n          return sign * parseInt(value, 8);\n        }\n\n        if (value.indexOf(':') !== -1) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseInt(v, 10));\n          });\n\n          value = 0;\n          base = 1;\n\n          digits.forEach(function (d) {\n            value += (d * base);\n            base *= 60;\n          });\n\n          return sign * value;\n\n        }\n\n        return sign * parseInt(value, 10);\n      }\n\n      function isInteger(object) {\n        return (Object.prototype.toString.call(object)) === '[object Number]' &&\n          (object % 1 === 0 && !common.isNegativeZero(object));\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:int', {\n        kind: 'scalar',\n        resolve: resolveYamlInteger,\n        construct: constructYamlInteger,\n        predicate: isInteger,\n        represent: {\n          binary: function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n          octal: function (obj) { return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1); },\n          decimal: function (obj) { return obj.toString(10); },\n          /* eslint-disable max-len */\n          hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1); }\n        },\n        defaultStyle: 'decimal',\n        styleAliases: {\n          binary: [2, 'bin'],\n          octal: [8, 'oct'],\n          decimal: [10, 'dec'],\n          hexadecimal: [16, 'hex']\n        }\n      });\n\n    }, { \"../common\": 2, \"../type\": 13 }], 18: [function (require, module, exports) {\n      'use strict';\n\n      var esprima;\n\n      // Browserified version does not have esprima\n      //\n      // 1. For node.js just require module as deps\n      // 2. For browser try to require mudule via external AMD system.\n      //    If not found - try to fallback to window.esprima. If not\n      //    found too - then fail to parse.\n      //\n      try {\n        // workaround to exclude package from browserify list.\n        var _require = require;\n        esprima = _require('esprima');\n      } catch (_) {\n        /* eslint-disable no-redeclare */\n        /* global window */\n        if (typeof window !== 'undefined') esprima = window.esprima;\n      }\n\n      var Type = require('../../type');\n\n      function resolveJavascriptFunction(data) {\n        if (data === null) return false;\n\n        try {\n          var source = '(' + data + ')',\n            ast = esprima.parse(source, { range: true });\n\n          if (ast.type !== 'Program' ||\n            ast.body.length !== 1 ||\n            ast.body[0].type !== 'ExpressionStatement' ||\n            (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n              ast.body[0].expression.type !== 'FunctionExpression')) {\n            return false;\n          }\n\n          return true;\n        } catch (err) {\n          return false;\n        }\n      }\n\n      function constructJavascriptFunction(data) {\n        /*jslint evil:true*/\n\n        var source = '(' + data + ')',\n          ast = esprima.parse(source, { range: true }),\n          params = [],\n          body;\n\n        if (ast.type !== 'Program' ||\n          ast.body.length !== 1 ||\n          ast.body[0].type !== 'ExpressionStatement' ||\n          (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n            ast.body[0].expression.type !== 'FunctionExpression')) {\n          throw new Error('Failed to resolve function');\n        }\n\n        ast.body[0].expression.params.forEach(function (param) {\n          params.push(param.name);\n        });\n\n        body = ast.body[0].expression.body.range;\n\n        // Esprima's ranges include the first '{' and the last '}' characters on\n        // function expressions. So cut them out.\n        if (ast.body[0].expression.body.type === 'BlockStatement') {\n          /*eslint-disable no-new-func*/\n          return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n        }\n        // ES6 arrow functions can omit the BlockStatement. In that case, just return\n        // the body.\n        /*eslint-disable no-new-func*/\n        return new Function(params, 'return ' + source.slice(body[0], body[1]));\n      }\n\n      function representJavascriptFunction(object /*, style*/) {\n        return object.toString();\n      }\n\n      function isFunction(object) {\n        return Object.prototype.toString.call(object) === '[object Function]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/function', {\n        kind: 'scalar',\n        resolve: resolveJavascriptFunction,\n        construct: constructJavascriptFunction,\n        predicate: isFunction,\n        represent: representJavascriptFunction\n      });\n\n    }, { \"../../type\": 13 }], 19: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptRegExp(data) {\n        if (data === null) return false;\n        if (data.length === 0) return false;\n\n        var regexp = data,\n          tail = /\\/([gim]*)$/.exec(data),\n          modifiers = '';\n\n        // if regexp starts with '/' it can have modifiers and must be properly closed\n        // `/foo/gim` - modifiers tail can be maximum 3 chars\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n\n          if (modifiers.length > 3) return false;\n          // if expression starts with /, is should be properly terminated\n          if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n        }\n\n        return true;\n      }\n\n      function constructJavascriptRegExp(data) {\n        var regexp = data,\n          tail = /\\/([gim]*)$/.exec(data),\n          modifiers = '';\n\n        // `/foo/gim` - tail can be maximum 4 chars\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n          regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n        }\n\n        return new RegExp(regexp, modifiers);\n      }\n\n      function representJavascriptRegExp(object /*, style*/) {\n        var result = '/' + object.source + '/';\n\n        if (object.global) result += 'g';\n        if (object.multiline) result += 'm';\n        if (object.ignoreCase) result += 'i';\n\n        return result;\n      }\n\n      function isRegExp(object) {\n        return Object.prototype.toString.call(object) === '[object RegExp]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/regexp', {\n        kind: 'scalar',\n        resolve: resolveJavascriptRegExp,\n        construct: constructJavascriptRegExp,\n        predicate: isRegExp,\n        represent: representJavascriptRegExp\n      });\n\n    }, { \"../../type\": 13 }], 20: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptUndefined() {\n        return true;\n      }\n\n      function constructJavascriptUndefined() {\n        /*eslint-disable no-undefined*/\n        return undefined;\n      }\n\n      function representJavascriptUndefined() {\n        return '';\n      }\n\n      function isUndefined(object) {\n        return typeof object === 'undefined';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/undefined', {\n        kind: 'scalar',\n        resolve: resolveJavascriptUndefined,\n        construct: constructJavascriptUndefined,\n        predicate: isUndefined,\n        represent: representJavascriptUndefined\n      });\n\n    }, { \"../../type\": 13 }], 21: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:map', {\n        kind: 'mapping',\n        construct: function (data) { return data !== null ? data : {}; }\n      });\n\n    }, { \"../type\": 13 }], 22: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlMerge(data) {\n        return data === '<<' || data === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:merge', {\n        kind: 'scalar',\n        resolve: resolveYamlMerge\n      });\n\n    }, { \"../type\": 13 }], 23: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlNull(data) {\n        if (data === null) return true;\n\n        var max = data.length;\n\n        return (max === 1 && data === '~') ||\n          (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n      }\n\n      function constructYamlNull() {\n        return null;\n      }\n\n      function isNull(object) {\n        return object === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:null', {\n        kind: 'scalar',\n        resolve: resolveYamlNull,\n        construct: constructYamlNull,\n        predicate: isNull,\n        represent: {\n          canonical: function () { return '~'; },\n          lowercase: function () { return 'null'; },\n          uppercase: function () { return 'NULL'; },\n          camelcase: function () { return 'Null'; }\n        },\n        defaultStyle: 'lowercase'\n      });\n\n    }, { \"../type\": 13 }], 24: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlOmap(data) {\n        if (data === null) return true;\n\n        var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n          object = data;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          pairHasKey = false;\n\n          if (_toString.call(pair) !== '[object Object]') return false;\n\n          for (pairKey in pair) {\n            if (_hasOwnProperty.call(pair, pairKey)) {\n              if (!pairHasKey) pairHasKey = true;\n              else return false;\n            }\n          }\n\n          if (!pairHasKey) return false;\n\n          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n          else return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlOmap(data) {\n        return data !== null ? data : [];\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:omap', {\n        kind: 'sequence',\n        resolve: resolveYamlOmap,\n        construct: constructYamlOmap\n      });\n\n    }, { \"../type\": 13 }], 25: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlPairs(data) {\n        if (data === null) return true;\n\n        var index, length, pair, keys, result,\n          object = data;\n\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n\n          if (_toString.call(pair) !== '[object Object]') return false;\n\n          keys = Object.keys(pair);\n\n          if (keys.length !== 1) return false;\n\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return true;\n      }\n\n      function constructYamlPairs(data) {\n        if (data === null) return [];\n\n        var index, length, pair, keys, result,\n          object = data;\n\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n\n          keys = Object.keys(pair);\n\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return result;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:pairs', {\n        kind: 'sequence',\n        resolve: resolveYamlPairs,\n        construct: constructYamlPairs\n      });\n\n    }, { \"../type\": 13 }], 26: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:seq', {\n        kind: 'sequence',\n        construct: function (data) { return data !== null ? data : []; }\n      });\n\n    }, { \"../type\": 13 }], 27: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function resolveYamlSet(data) {\n        if (data === null) return true;\n\n        var key, object = data;\n\n        for (key in object) {\n          if (_hasOwnProperty.call(object, key)) {\n            if (object[key] !== null) return false;\n          }\n        }\n\n        return true;\n      }\n\n      function constructYamlSet(data) {\n        return data !== null ? data : {};\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:set', {\n        kind: 'mapping',\n        resolve: resolveYamlSet,\n        construct: constructYamlSet\n      });\n\n    }, { \"../type\": 13 }], 28: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:str', {\n        kind: 'scalar',\n        construct: function (data) { return data !== null ? data : ''; }\n      });\n\n    }, { \"../type\": 13 }], 29: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var YAML_DATE_REGEXP = new RegExp(\n        '^([0-9][0-9][0-9][0-9])' + // [1] year\n        '-([0-9][0-9])' + // [2] month\n        '-([0-9][0-9])$');                   // [3] day\n\n      var YAML_TIMESTAMP_REGEXP = new RegExp(\n        '^([0-9][0-9][0-9][0-9])' + // [1] year\n        '-([0-9][0-9]?)' + // [2] month\n        '-([0-9][0-9]?)' + // [3] day\n        '(?:[Tt]|[ \\\\t]+)' + // ...\n        '([0-9][0-9]?)' + // [4] hour\n        ':([0-9][0-9])' + // [5] minute\n        ':([0-9][0-9])' + // [6] second\n        '(?:\\\\.([0-9]*))?' + // [7] fraction\n        '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n        '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\n      function resolveYamlTimestamp(data) {\n        if (data === null) return false;\n        if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n        return false;\n      }\n\n      function constructYamlTimestamp(data) {\n        var match, year, month, day, hour, minute, second, fraction = 0,\n          delta = null, tz_hour, tz_minute, date;\n\n        match = YAML_DATE_REGEXP.exec(data);\n        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n        if (match === null) throw new Error('Date resolve error');\n\n        // match: [1] year [2] month [3] day\n\n        year = +(match[1]);\n        month = +(match[2]) - 1; // JS month starts with 0\n        day = +(match[3]);\n\n        if (!match[4]) { // no hour\n          return new Date(Date.UTC(year, month, day));\n        }\n\n        // match: [4] hour [5] minute [6] second [7] fraction\n\n        hour = +(match[4]);\n        minute = +(match[5]);\n        second = +(match[6]);\n\n        if (match[7]) {\n          fraction = match[7].slice(0, 3);\n          while (fraction.length < 3) { // milli-seconds\n            fraction += '0';\n          }\n          fraction = +fraction;\n        }\n\n        // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n        if (match[9]) {\n          tz_hour = +(match[10]);\n          tz_minute = +(match[11] || 0);\n          delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n          if (match[9] === '-') delta = -delta;\n        }\n\n        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n        if (delta) date.setTime(date.getTime() - delta);\n\n        return date;\n      }\n\n      function representYamlTimestamp(object /*, style*/) {\n        return object.toISOString();\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:timestamp', {\n        kind: 'scalar',\n        resolve: resolveYamlTimestamp,\n        construct: constructYamlTimestamp,\n        instanceOf: Date,\n        represent: representYamlTimestamp\n      });\n\n    }, { \"../type\": 13 }], \"/\": [function (require, module, exports) {\n      'use strict';\n\n\n      var yaml = require('./lib/js-yaml.js');\n\n\n      module.exports = yaml;\n\n    }, { \"./lib/js-yaml.js\": 1 }]\n  }, {}, [])(\"/\")\n});\n"],"sourceRoot":""}